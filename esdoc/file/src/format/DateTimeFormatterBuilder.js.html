<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">src/format/DateTimeFormatterBuilder.js | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <a data-ice="repoURL" href="https://github.com/js-joda/js-joda.git" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Clock.js~Clock.html">Clock</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/DayOfWeek.js~DayOfWeek.html">DayOfWeek</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Duration.js~Duration.html">Duration</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Enum.js~Enum.html">Enum</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Instant.js~Instant.html">Instant</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/LocalDate.js~LocalDate.html">LocalDate</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/LocalDateTime.js~LocalDateTime.html">LocalDateTime</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/LocalTime.js~LocalTime.html">LocalTime</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/MathUtil.js~MathUtil.html">MathUtil</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Month.js~Month.html">Month</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/MonthDay.js~MonthDay.html">MonthDay</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Period.js~Period.html">Period</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/StringUtil.js~StringUtil.html">StringUtil</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Year.js~Year.html">Year</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/YearConstants.js~YearConstants.html">YearConstants</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/YearMonth.js~YearMonth.html">YearMonth</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ZoneId.js~ZoneId.html">ZoneId</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ZoneIdFactory.js~ZoneIdFactory.html">ZoneIdFactory</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ZoneOffset.js~ZoneOffset.html">ZoneOffset</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ZoneRegion.js~ZoneRegion.html">ZoneRegion</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ZonedDateTime.js~ZonedDateTime.html">ZonedDateTime</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-abstractMethodFail">abstractMethodFail</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-assert">assert</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-requireInstance">requireInstance</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-requireNonNull">requireNonNull</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-convert">convert</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-MAX_SAFE_INTEGER">MAX_SAFE_INTEGER</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-MIN_SAFE_INTEGER">MIN_SAFE_INTEGER</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-ArithmeticException">ArithmeticException</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-DateTimeException">DateTimeException</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-DateTimeParseException">DateTimeParseException</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-IllegalArgumentException">IllegalArgumentException</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-IllegalStateException">IllegalStateException</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-NullPointerException">NullPointerException</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-UnsupportedTemporalTypeException">UnsupportedTemporalTypeException</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">chrono</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/chrono/ChronoLocalDate.js~ChronoLocalDate.html">ChronoLocalDate</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/chrono/ChronoLocalDateTime.js~ChronoLocalDateTime.html">ChronoLocalDateTime</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/chrono/ChronoZonedDateTime.js~ChronoZonedDateTime.html">ChronoZonedDateTime</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/chrono/IsoChronology.js~IsoChronology.html">IsoChronology</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">format</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/format/DateTimeBuilder.js~DateTimeBuilder.html">DateTimeBuilder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/format/DateTimeFormatter.js~DateTimeFormatter.html">DateTimeFormatter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder.html">DateTimeFormatterBuilder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/format/DateTimeParseContext.js~DateTimeParseContext.html">DateTimeParseContext</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/format/DateTimePrintContext.js~DateTimePrintContext.html">DateTimePrintContext</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/format/DecimalStyle.js~DecimalStyle.html">DecimalStyle</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/format/EnumMap.js~EnumMap.html">EnumMap</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/format/ParsePosition.js~ParsePosition.html">ParsePosition</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/format/ResolverStyle.js~ResolverStyle.html">ResolverStyle</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/format/SignStyle.js~SignStyle.html">SignStyle</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/format/StringBuilder.js~StringBuilder.html">StringBuilder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/format/TextStyle.js~TextStyle.html">TextStyle</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">temporal</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/temporal/ChronoField.js~ChronoField.html">ChronoField</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/temporal/ChronoUnit.js~ChronoUnit.html">ChronoUnit</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/temporal/IsoFields.js~IsoFields.html">IsoFields</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/temporal/TemporalAccessor.js~TemporalAccessor.html">TemporalAccessor</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/temporal/TemporalAdjusters.js~TemporalAdjusters.html">TemporalAdjusters</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/temporal/TemporalQueries.js~TemporalQueries.html">TemporalQueries</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/temporal/ValueRange.js~ValueRange.html">ValueRange</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-interface">I</span><span data-ice="name"><span><a href="class/src/temporal/Temporal.js~Temporal.html">Temporal</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-interface">I</span><span data-ice="name"><span><a href="class/src/temporal/TemporalAdjuster.js~TemporalAdjuster.html">TemporalAdjuster</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-interface">I</span><span data-ice="name"><span><a href="class/src/temporal/TemporalAmount.js~TemporalAmount.html">TemporalAmount</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-interface">I</span><span data-ice="name"><span><a href="class/src/temporal/TemporalField.js~TemporalField.html">TemporalField</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-interface">I</span><span data-ice="name"><span><a href="class/src/temporal/TemporalQuery.js~TemporalQuery.html">TemporalQuery</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-interface">I</span><span data-ice="name"><span><a href="class/src/temporal/TemporalUnit.js~TemporalUnit.html">TemporalUnit</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-nativeJs">nativeJs</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createTemporalQuery">createTemporalQuery</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">zone</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/zone/SystemDefaultZoneId.js~SystemDefaultZoneId.html">SystemDefaultZoneId</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/zone/SystemDefaultZoneRules.js~SystemDefaultZoneRules.html">SystemDefaultZoneRules</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/zone/ZoneRules.js~ZoneRules.html">ZoneRules</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/format/DateTimeFormatterBuilder.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/**
 * @copyright (c) 2016, Philipp Thuerwaechter &amp; Pattrick Hueper
 * @copyright (c) 2007-present, Stephen Colebourne &amp; Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */

import {assert, requireNonNull, requireInstance} from &apos;../assert&apos;;
import {ArithmeticException, DateTimeException, IllegalArgumentException, IllegalStateException} from &apos;../errors&apos;;
import {MathUtil} from &apos;../MathUtil&apos;;

import {Enum} from &apos;../Enum&apos;;
import {ZoneIdFactory} from &apos;../ZoneIdFactory&apos;;
import {LocalDate} from &apos;../LocalDate&apos;;
import {LocalDateTime} from &apos;../LocalDateTime&apos;;
import {ZoneOffset} from &apos;../ZoneOffset&apos;;
import {ZoneId} from &apos;../ZoneId&apos;;
import {ChronoLocalDate} from &apos;../chrono/ChronoLocalDate&apos;;
import {IsoChronology} from &apos;../chrono/IsoChronology&apos;;
import {ChronoField} from &apos;../temporal/ChronoField&apos;;
import {IsoFields} from &apos;../temporal/IsoFields&apos;;
import {TemporalQueries} from &apos;../temporal/TemporalQueries&apos;;

import {DateTimeFormatter} from &apos;./DateTimeFormatter&apos;;
import {DecimalStyle} from &apos;./DecimalStyle&apos;;
import {SignStyle} from &apos;./SignStyle&apos;;
import {TextStyle} from &apos;./TextStyle&apos;;
import {ResolverStyle} from &apos;./ResolverStyle&apos;;

const MAX_WIDTH = 15; // can&apos;t parse all numbers with more then 15 digits in javascript

export class DateTimeFormatterBuilder {

    /**
     * Constructs a new instance of the builder.
     *
     * @param {DateTimeFormatterBuilder} parent  the parent builder, not null
     * @param {boolean} optional  whether the formatter is optional, not null
     */
    constructor(parent=null, optional=false){
        /**
         * The currently active builder, used by the outermost builder.
         */
        this._active = this;
        /**
         * The parent builder, null for the outermost builder.
         */
        this._parent = parent;

        /**
         * The list of printers that will be used.
         */
        this._printerParsers = [];

        /**
         * Whether this builder produces an optional formatter.
         */
        this._optional = optional;
        /**
         * The width to pad the next field to.
         */
        this._padNextWidth = 0;

        /**
         * The character to pad the next field with.
         */
        this._padNextChar = null;

        /**
         * The index of the last variable width value parser.
         */
        this._valueParserIndex = -1;
    }

    /**
     * Changes the parse style to be case sensitive for the remainder of the formatter.
     * 
     * Parsing can be case sensitive or insensitive - by default it is case sensitive.
     * This method allows the case sensitivity setting of parsing to be changed.
     * 
     * Calling this method changes the state of the builder such that all
     * subsequent builder method calls will parse text in case sensitive mode.
     * See {@link #parseCaseInsensitive} for the opposite setting.
     * The parse case sensitive/insensitive methods may be called at any point
     * in the builder, thus the parser can swap between case parsing modes
     * multiple times during the parse.
     * 
     * Since the default is case sensitive, this method should only be used after
     * a previous call to {@code #parseCaseInsensitive}.
     *
     * @return {DateTimeFormatterBuilder} this, for chaining, not null
     */
    parseCaseSensitive() {
        this._appendInternalPrinterParser(SettingsParser.SENSITIVE);
        return this;
    }

    /**
     * Changes the parse style to be case insensitive for the remainder of the formatter.
     * 
     * Parsing can be case sensitive or insensitive - by default it is case sensitive.
     * This method allows the case sensitivity setting of parsing to be changed.
     * 
     * Calling this method changes the state of the builder such that all
     * subsequent builder method calls will parse text in case sensitive mode.
     * See {@link #parseCaseSensitive()} for the opposite setting.
     * The parse case sensitive/insensitive methods may be called at any point
     * in the builder, thus the parser can swap between case parsing modes
     * multiple times during the parse.
     *
     * @return {DateTimeFormatterBuilder} this, for chaining, not null
     */
    parseCaseInsensitive() {
        this._appendInternalPrinterParser(SettingsParser.INSENSITIVE);
        return this;
    }

    //-----------------------------------------------------------------------
    /**
     * Changes the parse style to be strict for the remainder of the formatter.
     * 
     * Parsing can be strict or lenient - by default its strict.
     * This controls the degree of flexibility in matching the text and sign styles.
     * 
     * When used, this method changes the parsing to be strict from this point onwards.
     * As strict is the default, this is normally only needed after calling {@link #parseLenient()}.
     * The change will remain in force until the end of the formatter that is eventually
     * constructed or until {@code parseLenient} is called.
     *
     * @return {DateTimeFormatterBuilder} this, for chaining, not null
     */
    parseStrict() {
        this._appendInternalPrinterParser(SettingsParser.STRICT);
        return this;
    }

    /**
     * Changes the parse style to be lenient for the remainder of the formatter.
     * Note that case sensitivity is set separately to this method.
     * 
     * Parsing can be strict or lenient - by default its strict.
     * This controls the degree of flexibility in matching the text and sign styles.
     * Applications calling this method should typically also call {@link #parseCaseInsensitive()}.
     * 
     * When used, this method changes the parsing to be strict from this point onwards.
     * The change will remain in force until the end of the formatter that is eventually
     * constructed or until {@code parseStrict} is called.
     *
     * @return {DateTimeFormatterBuilder} this, for chaining, not null
     */
    parseLenient() {
        this._appendInternalPrinterParser(SettingsParser.LENIENT);
        return this;
    }

    /**
     * appendValue function overloading
     */
    appendValue(){
        if(arguments.length === 1){
            return this._appendValue1.apply(this, arguments);
        } else if(arguments.length === 2){
            return this._appendValue2.apply(this, arguments);
        } else {
            return this._appendValue4.apply(this, arguments);
        }  
    }
    
    /**
     * Appends the value of a date-time field to the formatter using a normal
     * output style.
     * 
     * The value of the field will be output during a print.
     * If the value cannot be obtained then an exception will be thrown.
     * 
     * The value will be printed as per the normal print of an integer value.
     * Only negative numbers will be signed. No padding will be added.
     * 
     * The parser for a variable width value such as this normally behaves greedily,
     * requiring one digit, but accepting as many digits as possible.
     * This behavior can be affected by &apos;adjacent value parsing&apos;.
     * See {@link #appendValue(TemporalField, int)} for full details.
     *
     * @param field  the field to append, not null
     * @return {DateTimeFormatterBuilder} this, for chaining, not null
     */
    _appendValue1(field) {
        assert(field != null);
        this._appendValuePrinterParser(new NumberPrinterParser(field, 1, MAX_WIDTH, SignStyle.NORMAL));
        return this;
    }

    /**
     * Appends the value of a date-time field to the formatter using a fixed
     * width, zero-padded approach.
     * 
     * The value of the field will be output during a print.
     * If the value cannot be obtained then an exception will be thrown.
     * 
     * The value will be zero-padded on the left. If the size of the value
     * means that it cannot be printed within the width then an exception is thrown.
     * If the value of the field is negative then an exception is thrown during printing.
     * 
     * This method supports a special technique of parsing known as &apos;adjacent value parsing&apos;.
     * This technique solves the problem where a variable length value is followed by one or more
     * fixed length values. The standard parser is greedy, and thus it would normally
     * steal the digits that are needed by the fixed width value parsers that follow the
     * variable width one.
     * 
     * No action is required to initiate &apos;adjacent value parsing&apos;.
     * When a call to {@code appendValue} with a variable width is made, the builder
     * enters adjacent value parsing setup mode. If the immediately subsequent method
     * call or calls on the same builder are to this method, then the parser will reserve
     * space so that the fixed width values can be parsed.
     * 
     * For example, consider {@code builder.appendValue(YEAR).appendValue(MONTH_OF_YEAR, 2);}
     * The year is a variable width parse of between 1 and 19 digits.
     * The month is a fixed width parse of 2 digits.
     * Because these were appended to the same builder immediately after one another,
     * the year parser will reserve two digits for the month to parse.
     * Thus, the text &apos;201106&apos; will correctly parse to a year of 2011 and a month of 6.
     * Without adjacent value parsing, the year would greedily parse all six digits and leave
     * nothing for the month.
     * 
     * Adjacent value parsing applies to each set of fixed width not-negative values in the parser
     * that immediately follow any kind of variable width value.
     * Calling any other append method will end the setup of adjacent value parsing.
     * Thus, in the unlikely event that you need to avoid adjacent value parsing behavior,
     * simply add the {@code appendValue} to another {@code DateTimeFormatterBuilder}
     * and add that to this builder.
     * 
     * If adjacent parsing is active, then parsing must match exactly the specified
     * number of digits in both strict and lenient modes.
     * In addition, no positive or negative sign is permitted.
     *
     * @param field  the field to append, not null
     * @param width  the width of the printed field, from 1 to 19
     * @return this, for chaining, not null
     * @throws IllegalArgumentException if the width is invalid
     */
    _appendValue2(field, width) {
        assert(field != null);
        if (width &lt; 1 || width &gt; MAX_WIDTH) {
            throw new IllegalArgumentException(`The width must be from 1 to ${MAX_WIDTH} inclusive but was ${width}`);
        }
        var pp = new NumberPrinterParser(field, width, width, SignStyle.NOT_NEGATIVE);
        this._appendValuePrinterParser(pp);
        return this;
    }

    /**
     * Appends the value of a date-time field to the formatter providing full
     * control over printing.
     * 
     * The value of the field will be output during a print.
     * If the value cannot be obtained then an exception will be thrown.
     * 
     * This method provides full control of the numeric formatting, including
     * zero-padding and the positive/negative sign.
     * 
     * The parser for a variable width value such as this normally behaves greedily,
     * accepting as many digits as possible.
     * This behavior can be affected by &apos;adjacent value parsing&apos;.
     * See {@link #appendValue(TemporalField, int)} for full details.
     * 
     * In strict parsing mode, the minimum number of parsed digits is {@code minWidth}.
     * In lenient parsing mode, the minimum number of parsed digits is one.
     * 
     * If this method is invoked with equal minimum and maximum widths and a sign style of
     * {@code NOT_NEGATIVE} then it delegates to {@code appendValue(TemporalField,int)}.
     * In this scenario, the printing and parsing behavior described there occur.
     *
     * @param field  the field to append, not null
     * @param minWidth  the minimum field width of the printed field, from 1 to 19
     * @param maxWidth  the maximum field width of the printed field, from 1 to 19
     * @param signStyle  the positive/negative output style, not null
     * @return {DateTimeFormatterBuilder} this, for chaining, not null
     * @throws IllegalArgumentException if the widths are invalid
     */
    _appendValue4(field, minWidth, maxWidth, signStyle) {
        assert(field != null);
        if (minWidth === maxWidth &amp;&amp; signStyle === SignStyle.NOT_NEGATIVE) {
            return this._appendValue2(field, maxWidth);
        }
        if (minWidth &lt; 1 || minWidth &gt; MAX_WIDTH) {
            throw new IllegalArgumentException(`The minimum width must be from 1 to ${MAX_WIDTH} inclusive but was ${minWidth}`);
        }
        if (maxWidth &lt; 1 || maxWidth &gt; MAX_WIDTH) {
            throw new IllegalArgumentException(`The minimum width must be from 1 to ${MAX_WIDTH} inclusive but was ${maxWidth}`);
        }
        if (maxWidth &lt; minWidth) {
            throw new IllegalArgumentException(`The maximum width must exceed or equal the minimum width but ${maxWidth} &lt; ${minWidth}`);
        }
        var pp = new NumberPrinterParser(field, minWidth, maxWidth, signStyle);
        this._appendValuePrinterParser(pp);
        return this;
    }

    /**
     * appendValueReduced function overloading
     */
    appendValueReduced() {
        if (arguments.length === 4 &amp;&amp; arguments[3] instanceof ChronoLocalDate) {
            return this._appendValueReducedFieldWidthMaxWidthBaseDate.apply(this, arguments);
        } else {
            return this._appendValueReducedFieldWidthMaxWidthBaseValue.apply(this, arguments);
        }
    }
    
    /**
     * Appends the reduced value of a date-time field to the formatter.
     * &lt;p&gt;
     * Since fields such as year vary by chronology, it is recommended to use the
     * {@link #appendValueReduced(TemporalField, int, int, ChronoLocalDate)} date}
     * variant of this method in most cases. This variant is suitable for
     * simple fields or working with only the ISO chronology.
     * &lt;p&gt;
     * For formatting, the {@code width} and {@code maxWidth} are used to
     * determine the number of characters to format.
     * If they are equal then the format is fixed width.
     * If the value of the field is within the range of the {@code baseValue} using
     * {@code width} characters then the reduced value is formatted otherwise the value is
     * truncated to fit {@code maxWidth}.
     * The rightmost characters are output to match the width, left padding with zero.
     * &lt;p&gt;
     * For strict parsing, the number of characters allowed by {@code width} to {@code maxWidth} are parsed.
     * For lenient parsing, the number of characters must be at least 1 and less than 10.
     * If the number of digits parsed is equal to {@code width} and the value is positive,
     * the value of the field is computed to be the first number greater than
     * or equal to the {@code baseValue} with the same least significant characters,
     * otherwise the value parsed is the field value.
     * This allows a reduced value to be entered for values in range of the baseValue
     * and width and absolute values can be entered for values outside the range.
     * &lt;p&gt;
     * For example, a base value of {@code 1980} and a width of {@code 2} will have
     * valid values from {@code 1980} to {@code 2079}.
     * During parsing, the text {@code &quot;12&quot;} will result in the value {@code 2012} as that
     * is the value within the range where the last two characters are &quot;12&quot;.
     * By contrast, parsing the text {@code &quot;1915&quot;} will result in the value {@code 1915}.
     *
     * @param {TemporalField} field  the field to append, not null
     * @param {number} width  the field width of the printed and parsed field, from 1 to 10
     * @param {number} maxWidth  the maximum field width of the printed field, from 1 to 10
     * @param {number} baseValue  the base value of the range of valid values
     * @return {DateTimeFormatterBuilder} this, for chaining, not null
     * @throws IllegalArgumentException if the width or base value is invalid
     */
    _appendValueReducedFieldWidthMaxWidthBaseValue(field, width, maxWidth, baseValue) {
        requireNonNull(field, &apos;field&apos;);
        let pp = new ReducedPrinterParser(field, width, maxWidth, baseValue, null);
        this._appendValuePrinterParser(pp);
        return this;
    }

    /**
     * Appends the reduced value of a date-time field to the formatter.
     * &lt;p&gt;
     * This is typically used for formatting and parsing a two digit year.
     * &lt;p&gt;
     * The base date is used to calculate the full value during parsing.
     * For example, if the base date is 1950-01-01 then parsed values for
     * a two digit year parse will be in the range 1950-01-01 to 2049-12-31.
     * Only the year would be extracted from the date, thus a base date of
     * 1950-08-25 would also parse to the range 1950-01-01 to 2049-12-31.
     * This behavior is necessary to support fields such as week-based-year
     * or other calendar systems where the parsed value does not align with
     * standard ISO years.
     * &lt;p&gt;
     * The exact behavior is as follows. Parse the full set of fields and
     * determine the effective chronology using the last chronology if
     * it appears more than once. Then convert the base date to the
     * effective chronology. Then extract the specified field from the
     * chronology-specific base date and use it to determine the
     * {@code baseValue} used below.
     * &lt;p&gt;
     * For formatting, the {@code width} and {@code maxWidth} are used to
     * determine the number of characters to format.
     * If they are equal then the format is fixed width.
     * If the value of the field is within the range of the {@code baseValue} using
     * {@code width} characters then the reduced value is formatted otherwise the value is
     * truncated to fit {@code maxWidth}.
     * The rightmost characters are output to match the width, left padding with zero.
     * &lt;p&gt;
     * For strict parsing, the number of characters allowed by {@code width} to {@code maxWidth} are parsed.
     * For lenient parsing, the number of characters must be at least 1 and less than 10.
     * If the number of digits parsed is equal to {@code width} and the value is positive,
     * the value of the field is computed to be the first number greater than
     * or equal to the {@code baseValue} with the same least significant characters,
     * otherwise the value parsed is the field value.
     * This allows a reduced value to be entered for values in range of the baseValue
     * and width and absolute values can be entered for values outside the range.
     * &lt;p&gt;
     * For example, a base value of {@code 1980} and a width of {@code 2} will have
     * valid values from {@code 1980} to {@code 2079}.
     * During parsing, the text {@code &quot;12&quot;} will result in the value {@code 2012} as that
     * is the value within the range where the last two characters are &quot;12&quot;.
     * By contrast, parsing the text {@code &quot;1915&quot;} will result in the value {@code 1915}.
     *
     * @param {TemporaField} field  the field to append, not null
     * @param {number} width  the field width of the printed and parsed field, from 1 to 10
     * @param {number} maxWidth  the maximum field width of the printed field, from 1 to 10
     * @param {ChronoLocalDate} baseDate  the base date used to calculate the base value for the range
     *  of valid values in the parsed chronology, not null
     * @return {DateTimeFormatterBuilder} this, for chaining, not null
     * @throws IllegalArgumentException if the width or base value is invalid
     */
    _appendValueReducedFieldWidthMaxWidthBaseDate(field, width, maxWidth, baseDate) {
        requireNonNull(field, &apos;field&apos;);
        requireNonNull(baseDate, &apos;baseDate&apos;);
        requireInstance(baseDate, ChronoLocalDate, &apos;baseDate&apos;);
        let pp = new ReducedPrinterParser(field, width, maxWidth, 0, baseDate);
        this._appendValuePrinterParser(pp);
        return this;
    }

    /**
     * Appends a fixed width printer-parser.
     *
     * @param pp  the printer-parser, not null
     * @return {DateTimeFormatterBuilder} this, for chaining, not null
     */
    _appendValuePrinterParser(pp) {
        assert(pp != null);
        if (this._active._valueParserIndex &gt;= 0 &amp;&amp;
                this._active._printerParsers[this._active._valueParserIndex] instanceof NumberPrinterParser) {
            var activeValueParser = this._active._valueParserIndex;

            // adjacent parsing mode, update setting in previous parsers
            var basePP = this._active._printerParsers[activeValueParser];
            if (pp.minWidth() === pp.maxWidth() &amp;&amp; pp.signStyle() === SignStyle.NOT_NEGATIVE) {
                // Append the width to the subsequentWidth of the active parser
                basePP = basePP.withSubsequentWidth(pp.maxWidth());
                // Append the new parser as a fixed width
                this._appendInternal(pp.withFixedWidth());
                // Retain the previous active parser
                this._active._valueParserIndex = activeValueParser;
            } else {
                // Modify the active parser to be fixed width
                basePP = basePP.withFixedWidth();
                // The new parser becomes the mew active parser
                this._active._valueParserIndex = this._appendInternal(pp);
            }
            // Replace the modified parser with the updated one
            this._active._printerParsers[activeValueParser] = basePP;
        } else {
            // The new Parser becomes the active parser
            this._active._valueParserIndex = this._appendInternal(pp);
        }
        return this;
    }

    //-----------------------------------------------------------------------
    /**
     * Appends the fractional value of a date-time field to the formatter.
     * &lt;p&gt;
     * The fractional value of the field will be output including the
     * preceding decimal point. The preceding value is not output.
     * For example, the second-of-minute value of 15 would be output as {@code .25}.
     * &lt;p&gt;
     * The width of the printed fraction can be controlled. Setting the
     * minimum width to zero will cause no output to be generated.
     * The printed fraction will have the minimum width necessary between
     * the minimum and maximum widths - trailing zeroes are omitted.
     * No rounding occurs due to the maximum width - digits are simply dropped.
     * &lt;p&gt;
     * When parsing in strict mode, the number of parsed digits must be between
     * the minimum and maximum width. When parsing in lenient mode, the minimum
     * width is considered to be zero and the maximum is nine.
     * &lt;p&gt;
     * If the value cannot be obtained then an exception will be thrown.
     * If the value is negative an exception will be thrown.
     * If the field does not have a fixed set of valid values then an
     * exception will be thrown.
     * If the field value in the date-time to be printed is invalid it
     * cannot be printed and an exception will be thrown.
     *
     * @param {TemporalField} field  the field to append, not null
     * @param {Number} minWidth  the minimum width of the field excluding the decimal point, from 0 to 9
     * @param {Number} maxWidth  the maximum width of the field excluding the decimal point, from 1 to 9
     * @param {boolean} decimalPoint  whether to output the localized decimal point symbol
     * @return {DateTimeFormatterBuilder} this, for chaining, not null
     * @throws IllegalArgumentException if the field has a variable set of valid values or
     *  either width is invalid
     */
    appendFraction(field, minWidth, maxWidth, decimalPoint) {
        this._appendInternal(new FractionPrinterParser(field, minWidth, maxWidth, decimalPoint));
        return this;
    }

    /**
     * Appends an instant using ISO-8601 to the formatter with control over
     * the number of fractional digits.
     * &lt;p&gt;
     * Instants have a fixed output format, although this method provides some
     * control over the fractional digits. They are converted to a date-time
     * with a zone-offset of UTC and printed using the standard ISO-8601 format.
     * The localized decimal style is not used.
     * &lt;p&gt;
     * The {@code this.fractionalDigits} parameter allows the output of the fractional
     * second to be controlled. Specifying zero will cause no fractional digits
     * to be output. From 1 to 9 will output an increasing number of digits, using
     * zero right-padding if necessary. The special value -1 is used to output as
     * many digits as necessary to avoid any trailing zeroes.
     * &lt;p&gt;
     * When parsing in strict mode, the number of parsed digits must match the
     * fractional digits. When parsing in lenient mode, any number of fractional
     * digits from zero to nine are accepted.
     * &lt;p&gt;
     * The instant is obtained using {@link ChronoField#INSTANT_SECONDS INSTANT_SECONDS}
     * and optionally (@code NANO_OF_SECOND). The value of {@code INSTANT_SECONDS}
     * may be outside the maximum range of {@code LocalDateTime}.
     * &lt;p&gt;
     * The {@linkplain ResolverStyle resolver style} has no effect on instant parsing.
     * The end-of-day time of &apos;24:00&apos; is handled as midnight at the start of the following day.
     * The leap-second time of &apos;23:59:59&apos; is handled to some degree, see
     * {@link DateTimeFormatter#parsedLeapSecond()} for full details.
     * &lt;p&gt;
     * An alternative to this method is to format/parse the instant as a single
     * epoch-seconds value. That is achieved using {@code appendValue(INSTANT_SECONDS)}.
     *
     * @param {number} [fractionalDigits=-2] - the number of fractional second digits to format with,
     *  from 0 to 9, or -1 to use as many digits as necessary
     * @return {DateTimeFormatterBuilder} this, for chaining, not null
     */
    appendInstant(fractionalDigits=-2) {
        if (fractionalDigits &lt; -2 || fractionalDigits &gt; 9) {
            throw new IllegalArgumentException(&apos;Invalid fractional digits: &apos; + fractionalDigits);
        }
        this._appendInternal(new InstantPrinterParser(fractionalDigits));
        return this;
    }


    /**
     * Appends the zone offset, such as &apos;+01:00&apos;, to the formatter.
     * &lt;p&gt;
     * This appends an instruction to print/parse the offset ID to the builder.
     * This is equivalent to calling {@code appendOffset(&quot;HH:MM:ss&quot;, &quot;Z&quot;)}.
     *
     * @return {DateTimeFormatterBuilder} this, for chaining, not null
     */
    appendOffsetId() {
        this._appendInternal(OffsetIdPrinterParser.INSTANCE_ID);
        return this;
    }
    
    /**
     * Appends the zone offset, such as &apos;+01:00&apos;, to the formatter.
     * &lt;p&gt;
     * This appends an instruction to print/parse the offset ID to the builder.
     * &lt;p&gt;
     * During printing, the offset is obtained using a mechanism equivalent
     * to querying the temporal with {@link TemporalQueries#offset()}.
     * It will be printed using the format defined below.
     * If the offset cannot be obtained then an exception is thrown unless the
     * section of the formatter is optional.
     * &lt;p&gt;
     * During parsing, the offset is parsed using the format defined below.
     * If the offset cannot be parsed then an exception is thrown unless the
     * section of the formatter is optional.
     * &lt;p&gt;
     * The format of the offset is controlled by a pattern which must be one
     * of the following:
     * &lt;p&gt;&lt;ul&gt;
     * &lt;li&gt;{@code +HH} - hour only, ignoring minute and second
     * &lt;li&gt;{@code +HHmm} - hour, with minute if non-zero, ignoring second, no colon
     * &lt;li&gt;{@code +HH:mm} - hour, with minute if non-zero, ignoring second, with colon
     * &lt;li&gt;{@code +HHMM} - hour and minute, ignoring second, no colon
     * &lt;li&gt;{@code +HH:MM} - hour and minute, ignoring second, with colon
     * &lt;li&gt;{@code +HHMMss} - hour and minute, with second if non-zero, no colon
     * &lt;li&gt;{@code +HH:MM:ss} - hour and minute, with second if non-zero, with colon
     * &lt;li&gt;{@code +HHMMSS} - hour, minute and second, no colon
     * &lt;li&gt;{@code +HH:MM:SS} - hour, minute and second, with colon
     * &lt;/ul&gt;&lt;p&gt;
     * The &quot;no offset&quot; text controls what text is printed when the total amount of
     * the offset fields to be output is zero.
     * Example values would be &apos;Z&apos;, &apos;+00:00&apos;, &apos;UTC&apos; or &apos;GMT&apos;.
     * Three formats are accepted for parsing UTC - the &quot;no offset&quot; text, and the
     * plus and minus versions of zero defined by the pattern.
     *
     * @param {String} pattern  the pattern to use, not null
     * @param {String} noOffsetText  the text to use when the offset is zero, not null
     * @return {DateTimeFormatterBuilder} this, for chaining, not null
     */
    appendOffset(pattern, noOffsetText) {
        this._appendInternalPrinterParser(new OffsetIdPrinterParser(noOffsetText, pattern));
        return this;
    }

    /**
      * Appends the time-zone ID, such as &apos;Europe/Paris&apos; or &apos;+02:00&apos;, to the formatter.
      * &lt;p&gt;
      * This appends an instruction to print/parse the zone ID to the builder.
      * The zone ID is obtained in a strict manner suitable for {@code ZonedDateTime}.
      * By contrast, {@code OffsetDateTime} does not have a zone ID suitable
      * for use with this method, see {@link #appendZoneOrOffsetId()}.
      * &lt;p&gt;
      * During printing, the zone is obtained using a mechanism equivalent
      * to querying the temporal with {@link TemporalQueries#zoneId()}.
      * It will be printed using the result of {@link ZoneId#getId()}.
      * If the zone cannot be obtained then an exception is thrown unless the
      * section of the formatter is optional.
      * &lt;p&gt;
      * During parsing, the zone is parsed and must match a known zone or offset.
      * If the zone cannot be parsed then an exception is thrown unless the
      * section of the formatter is optional.
      *
      * @return {DateTimeFormatterBuilder} this, for chaining, not null
      * @see #appendZoneRegionId()
      */
    appendZoneId() {
        this._appendInternal(new ZoneIdPrinterParser(TemporalQueries.zoneId(), &apos;ZoneId()&apos;));
        return this;
    }

    //-----------------------------------------------------------------------
    /**
     * Appends the elements defined by the specified pattern to the builder.
     * &lt;p&gt;
     * All letters &apos;A&apos; to &apos;Z&apos; and &apos;a&apos; to &apos;z&apos; are reserved as pattern letters.
     * The characters &apos;{&apos; and &apos;}&apos; are reserved for future use.
     * The characters &apos;[&apos; and &apos;]&apos; indicate optional patterns.
     * The following pattern letters are defined:
     * &lt;pre&gt;
     *  Symbol  Meaning                     Presentation      Examples
     *  ------  -------                     ------------      -------
     *   G       era                         number/text       1; 01; AD; Anno Domini
     *   y       year                        year              2004; 04
     *   D       day-of-year                 number            189
     *   M       month-of-year               number/text       7; 07; Jul; July; J
     *   d       day-of-month                number            10
     *
     *   Q       quarter-of-year             number/text       3; 03; Q3
     *   Y       week-based-year             year              1996; 96
     *   w       week-of-year                number            27
     *   W       week-of-month               number            27
     *   e       localized day-of-week       number            2; Tue; Tuesday; T
     *   E       day-of-week                 number/text       2; Tue; Tuesday; T
     *   F       week-of-month               number            3
     *
     *   a       am-pm-of-day                text              PM
     *   h       clock-hour-of-am-pm (1-12)  number            12
     *   K       hour-of-am-pm (0-11)        number            0
     *   k       clock-hour-of-am-pm (1-24)  number            0
     *
     *   H       hour-of-day (0-23)          number            0
     *   m       minute-of-hour              number            30
     *   s       second-of-minute            number            55
     *   S       fraction-of-second          fraction          978
     *   A       milli-of-day                number            1234
     *   n       nano-of-second              number            987654321
     *   N       nano-of-day                 number            1234000000
     *
     *   V       time-zone ID                zone-id           America/Los_Angeles; Z; -08:30
     *   z       time-zone name              zone-name         Pacific Standard Time; PST
     *   X       zone-offset &apos;Z&apos; for zero    offset-X          Z; -08; -0830; -08:30; -083015; -08:30:15;
     *   x       zone-offset                 offset-x          +0000; -08; -0830; -08:30; -083015; -08:30:15;
     *   Z       zone-offset                 offset-Z          +0000; -0800; -08:00;
     *
     *   p       pad next                    pad modifier      1
     *
     *   &apos;       escape for text             delimiter
     *   &apos;&apos;      single quote                literal           &apos;
     *   [       optional section start
     *   ]       optional section end
     *   {}      reserved for future use
     * &lt;/pre&gt;
     * &lt;p&gt;
     * The count of pattern letters determine the format.
     * &lt;p&gt;
     * &lt;b&gt;Text&lt;/b&gt;: The text style is determined based on the number of pattern letters used.
     * Less than 4 pattern letters will use the {@link TextStyle#SHORT short form}.
     * Exactly 4 pattern letters will use the {@link TextStyle#FULL full form}.
     * Exactly 5 pattern letters will use the {@link TextStyle#NARROW narrow form}.
     * &lt;p&gt;
     * &lt;b&gt;Number&lt;/b&gt;: If the count of letters is one, then the value is printed using the minimum number
     * of digits and without padding as per {@link #appendValue(TemporalField)}. Otherwise, the
     * count of digits is used as the width of the output field as per {@link #appendValue(TemporalField, int)}.
     * &lt;p&gt;
     * &lt;b&gt;Number/Text&lt;/b&gt;: If the count of pattern letters is 3 or greater, use the Text rules above.
     * Otherwise use the Number rules above.
     * &lt;p&gt;
     * &lt;b&gt;Fraction&lt;/b&gt;: Outputs the nano-of-second field as a fraction-of-second.
     * The nano-of-second value has nine digits, thus the count of pattern letters is from 1 to 9.
     * If it is less than 9, then the nano-of-second value is truncated, with only the most
     * significant digits being output.
     * When parsing in strict mode, the number of parsed digits must match the count of pattern letters.
     * When parsing in lenient mode, the number of parsed digits must be at least the count of pattern
     * letters, up to 9 digits.
     * &lt;p&gt;
     * &lt;b&gt;Year&lt;/b&gt;: The count of letters determines the minimum field width below which padding is used.
     * If the count of letters is two, then a {@link #appendValueReduced reduced} two digit form is used.
     * For printing, this outputs the rightmost two digits. For parsing, this will parse using the
     * base value of 2000, resulting in a year within the range 2000 to 2099 inclusive.
     * If the count of letters is less than four (but not two), then the sign is only output for negative
     * years as per {@link SignStyle#NORMAL}.
     * Otherwise, the sign is output if the pad width is exceeded, as per {@link SignStyle#EXCEEDS_PAD}
     * &lt;p&gt;
     * &lt;b&gt;ZoneId&lt;/b&gt;: This outputs the time-zone ID, such as &apos;Europe/Paris&apos;.
     * If the count of letters is two, then the time-zone ID is output.
     * Any other count of letters throws {@code IllegalArgumentException}.
     * &lt;pre&gt;
     *  Pattern     Equivalent builder methods
     *   VV          appendZoneId()
     * &lt;/pre&gt;
     * &lt;p&gt;
     * &lt;b&gt;Zone names&lt;/b&gt;: This outputs the display name of the time-zone ID.
     * If the count of letters is one, two or three, then the short name is output.
     * If the count of letters is four, then the full name is output.
     * Five or more letters throws {@code IllegalArgumentException}.
     * &lt;pre&gt;
     *  Pattern     Equivalent builder methods
     *   z           appendZoneText(TextStyle.SHORT)
     *   zz          appendZoneText(TextStyle.SHORT)
     *   zzz         appendZoneText(TextStyle.SHORT)
     *   zzzz        appendZoneText(TextStyle.FULL)
     * &lt;/pre&gt;
     * &lt;p&gt;
     * &lt;b&gt;Offset X and x&lt;/b&gt;: This formats the offset based on the number of pattern letters.
     * One letter outputs just the hour&apos;, such as &apos;+01&apos;, unless the minute is non-zero
     * in which case the minute is also output, such as &apos;+0130&apos;.
     * Two letters outputs the hour and minute, without a colon, such as &apos;+0130&apos;.
     * Three letters outputs the hour and minute, with a colon, such as &apos;+01:30&apos;.
     * Four letters outputs the hour and minute and optional second, without a colon, such as &apos;+013015&apos;.
     * Five letters outputs the hour and minute and optional second, with a colon, such as &apos;+01:30:15&apos;.
     * Six or more letters throws {@code IllegalArgumentException}.
     * Pattern letter &apos;X&apos; (upper case) will output &apos;Z&apos; when the offset to be output would be zero,
     * whereas pattern letter &apos;x&apos; (lower case) will output &apos;+00&apos;, &apos;+0000&apos;, or &apos;+00:00&apos;.
     * &lt;pre&gt;
     *  Pattern     Equivalent builder methods
     *   X           appendOffset(&quot;+HHmm&quot;,&quot;Z&quot;)
     *   XX          appendOffset(&quot;+HHMM&quot;,&quot;Z&quot;)
     *   XXX         appendOffset(&quot;+HH:MM&quot;,&quot;Z&quot;)
     *   XXXX        appendOffset(&quot;+HHMMss&quot;,&quot;Z&quot;)
     *   XXXXX       appendOffset(&quot;+HH:MM:ss&quot;,&quot;Z&quot;)
     *   x           appendOffset(&quot;+HHmm&quot;,&quot;+00&quot;)
     *   xx          appendOffset(&quot;+HHMM&quot;,&quot;+0000&quot;)
     *   xxx         appendOffset(&quot;+HH:MM&quot;,&quot;+00:00&quot;)
     *   xxxx        appendOffset(&quot;+HHMMss&quot;,&quot;+0000&quot;)
     *   xxxxx       appendOffset(&quot;+HH:MM:ss&quot;,&quot;+00:00&quot;)
     * &lt;/pre&gt;
     * &lt;p&gt;
     * &lt;b&gt;Offset Z&lt;/b&gt;: This formats the offset based on the number of pattern letters.
     * One, two or three letters outputs the hour and minute, without a colon, such as &apos;+0130&apos;.
     * Four or more letters throws {@code IllegalArgumentException}.
     * The output will be &apos;+0000&apos; when the offset is zero.
     * &lt;pre&gt;
     *  Pattern     Equivalent builder methods
     *   Z           appendOffset(&quot;+HHMM&quot;,&quot;+0000&quot;)
     *   ZZ          appendOffset(&quot;+HHMM&quot;,&quot;+0000&quot;)
     *   ZZZ         appendOffset(&quot;+HHMM&quot;,&quot;+0000&quot;)
     * &lt;/pre&gt;
     * &lt;p&gt;
     * &lt;b&gt;Optional section&lt;/b&gt;: The optional section markers work exactly like calling {@link #optionalStart()}
     * and {@link #optionalEnd()}.
     * &lt;p&gt;
     * &lt;b&gt;Pad modifier&lt;/b&gt;: Modifies the pattern that immediately follows to be padded with spaces.
     * The pad width is determined by the number of pattern letters.
     * This is the same as calling {@link #padNext(int)}.
     * &lt;p&gt;
     * For example, &apos;ppH&apos; outputs the hour-of-day padded on the left with spaces to a width of 2.
     * &lt;p&gt;
     * Any unrecognized letter is an error.
     * Any non-letter character, other than &apos;[&apos;, &apos;]&apos;, &apos;{&apos;, &apos;}&apos; and the single quote will be output directly.
     * Despite this, it is recommended to use single quotes around all characters that you want to
     * output directly to ensure that future changes do not break your application.
     * &lt;p&gt;
     * Note that the pattern string is similar, but not identical, to
     * {@link java.text.SimpleDateFormat SimpleDateFormat}.
     * The pattern string is also similar, but not identical, to that defined by the
     * Unicode Common Locale Data Repository (CLDR/LDML).
     * Pattern letters &apos;E&apos; and &apos;u&apos; are merged, which changes the meaning of &quot;E&quot; and &quot;EE&quot; to be numeric.
     * Pattern letters &apos;X&apos; is aligned with Unicode CLDR/LDML, which affects pattern &apos;X&apos;.
     * Pattern letter &apos;y&apos; and &apos;Y&apos; parse years of two digits and more than 4 digits differently.
     * Pattern letters &apos;n&apos;, &apos;A&apos;, &apos;N&apos;, &apos;I&apos; and &apos;p&apos; are added.
     * Number types will reject large numbers.
     *
     * @param {String} pattern  the pattern to add, not null
     * @return {DateTimeFormatterBuilder} this, for chaining, not null
     * @throws IllegalArgumentException if the pattern is invalid
     */
    appendPattern(pattern) {
        requireNonNull(pattern, &apos;pattern&apos;);
        this._parsePattern(pattern);
        return this;
    }

    _parsePattern(pattern) {
        /** Map of letters to fields. */
        const FIELD_MAP = {
            &apos;G&apos;: ChronoField.ERA,
            &apos;y&apos;: ChronoField.YEAR_OF_ERA,
            &apos;u&apos;: ChronoField.YEAR,
            &apos;Q&apos;: IsoFields.QUARTER_OF_YEAR,
            &apos;q&apos;: IsoFields.QUARTER_OF_YEAR,
            &apos;M&apos;: ChronoField.MONTH_OF_YEAR,
            &apos;L&apos;: ChronoField.MONTH_OF_YEAR,
            &apos;D&apos;: ChronoField.DAY_OF_YEAR,
            &apos;d&apos;: ChronoField.DAY_OF_MONTH,
            &apos;F&apos;: ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH,
            &apos;E&apos;: ChronoField.DAY_OF_WEEK,
            &apos;c&apos;: ChronoField.DAY_OF_WEEK,
            &apos;e&apos;: ChronoField.DAY_OF_WEEK,
            &apos;a&apos;: ChronoField.AMPM_OF_DAY,
            &apos;H&apos;: ChronoField.HOUR_OF_DAY,
            &apos;k&apos;: ChronoField.CLOCK_HOUR_OF_DAY,
            &apos;K&apos;: ChronoField.HOUR_OF_AMPM,
            &apos;h&apos;: ChronoField.CLOCK_HOUR_OF_AMPM,
            &apos;m&apos;: ChronoField.MINUTE_OF_HOUR,
            &apos;s&apos;: ChronoField.SECOND_OF_MINUTE,
            &apos;S&apos;: ChronoField.NANO_OF_SECOND,
            &apos;A&apos;: ChronoField.MILLI_OF_DAY,
            &apos;n&apos;: ChronoField.NANO_OF_SECOND,
            &apos;N&apos;: ChronoField.NANO_OF_DAY
        };

        for (let pos = 0; pos &lt; pattern.length; pos++) {
            let cur = pattern.charAt(pos);
            if ((cur &gt;= &apos;A&apos; &amp;&amp; cur &lt;= &apos;Z&apos;) || (cur &gt;= &apos;a&apos; &amp;&amp; cur &lt;= &apos;z&apos;)) {
                let start = pos++;
                for (; pos &lt; pattern.length &amp;&amp; pattern.charAt(pos) === cur; pos++);  // short loop
                let count = pos - start;
                // padding
                if (cur === &apos;p&apos;) {
                    let pad = 0;
                    if (pos &lt; pattern.length) {
                        cur = pattern.charAt(pos);
                        if ((cur &gt;= &apos;A&apos; &amp;&amp; cur &lt;= &apos;Z&apos;) || (cur &gt;= &apos;a&apos; &amp;&amp; cur &lt;= &apos;z&apos;)) {
                            pad = count;
                            start = pos++;
                            for (; pos &lt; pattern.length &amp;&amp; pattern.charAt(pos) === cur; pos++);  // short loop
                            count = pos - start;
                        }
                    }
                    if (pad === 0) {
                        throw new IllegalArgumentException(
                            &apos;Pad letter \&apos;p\&apos; must be followed by valid pad pattern: &apos; + pattern);
                    }
                    this.padNext(pad); // pad and continue parsing
                }
                // main rules
                let field = FIELD_MAP[cur];
                if (field != null) {
                    this._parseField(cur, count, field);
                } else if (cur === &apos;z&apos;) {
                    //TODO:
                    throw new IllegalArgumentException(&apos;Pattern using (localized) text not implemented yet!&apos;);
                    if (count &gt; 4) {
                        throw new IllegalArgumentException(&apos;Too many pattern letters: &apos; + cur);
                    } else if (count === 4) {
                        this.appendZoneText(TextStyle.FULL);
                    } else {
                        this.appendZoneText(TextStyle.SHORT);
                    }
                } else if (cur === &apos;V&apos;) {
                    if (count !== 2) {
                        throw new IllegalArgumentException(&apos;Pattern letter count must be 2: &apos; + cur);
                    }
                    this.appendZoneId();
                } else if (cur === &apos;Z&apos;) {
                    if (count &lt; 4) {
                        this.appendOffset(&apos;+HHMM&apos;, &apos;+0000&apos;);
                    } else if (count === 4) {
                        //TODO:
                        throw new IllegalArgumentException(&apos;Pattern using (localized) text not implemented yet!&apos;);
                        this.appendLocalizedOffset(TextStyle.FULL);
                    } else if (count === 5) {
                        this.appendOffset(&apos;+HH:MM:ss&apos;, &apos;Z&apos;);
                    } else {
                        throw new IllegalArgumentException(&apos;Too many pattern letters: &apos; + cur);
                    }
                } else if (cur === &apos;O&apos;) {
                    //TODO:
                    throw new IllegalArgumentException(&apos;Pattern using (localized) text not implemented yet!&apos;);
                    if (count === 1) {
                        this.appendLocalizedOffset(TextStyle.SHORT);
                    } else if (count === 4) {
                        this.appendLocalizedOffset(TextStyle.FULL);
                    } else {
                        throw new IllegalArgumentException(&apos;Pattern letter count must be 1 or 4: &apos; + cur);
                    }
                } else if (cur === &apos;X&apos;) {
                    if (count &gt; 5) {
                        throw new IllegalArgumentException(&apos;Too many pattern letters: &apos; + cur);
                    }
                    this.appendOffset(OffsetIdPrinterParser.PATTERNS[count + (count === 1 ? 0 : 1)], &apos;Z&apos;);
                } else if (cur === &apos;x&apos;) {
                    if (count &gt; 5) {
                        throw new IllegalArgumentException(&apos;Too many pattern letters: &apos; + cur);
                    }
                    let zero = (count === 1 ? &apos;+00&apos; : (count % 2 === 0 ? &apos;+0000&apos; : &apos;+00:00&apos;));
                    this.appendOffset(OffsetIdPrinterParser.PATTERNS[count + (count === 1 ? 0 : 1)], zero);
                } else if (cur === &apos;W&apos;) {
                    if (count &gt; 1) {
                        throw new IllegalArgumentException(&apos;Too many pattern letters: &apos; + cur);
                    }
                    this._appendInternal(new OffsetIdPrinterParser(&apos;W&apos;, count));
                } else if (cur === &apos;w&apos;) {
                    if (count &gt; 2) {
                        throw new IllegalArgumentException(&apos;Too many pattern letters: &apos; + cur);
                    }
                    this._appendInternal(new OffsetIdPrinterParser(&apos;w&apos;, count));
                } else if (cur === &apos;Y&apos;) {
                    this._appendInternal(new OffsetIdPrinterParser(&apos;Y&apos;, count));
                } else {
                    throw new IllegalArgumentException(&apos;Unknown pattern letter: &apos; + cur);
                }
                pos--;

            } else if (cur === &apos;\&apos;&apos;) {
                // parse literals
                let start = pos++;
                for (; pos &lt; pattern.length; pos++) {
                    if (pattern.charAt(pos) === &apos;\&apos;&apos;) {
                        if (pos + 1 &lt; pattern.length &amp;&amp; pattern.charAt(pos + 1) === &apos;\&apos;&apos;) {
                            pos++;
                        } else {
                            break;  // end of literal
                        }
                    }
                }
                if (pos &gt;= pattern.length) {
                    throw new IllegalArgumentException(&apos;Pattern ends with an incomplete string literal: &apos; + pattern);
                }
                let str = pattern.substring(start + 1, pos);
                if (str.length === 0) {
                    this.appendLiteral(&apos;\&apos;&apos;);
                } else {
                    this.appendLiteral(str.replace(&apos;\&apos;\&apos;&apos;, &apos;\&apos;&apos;));
                }

            } else if (cur === &apos;[&apos;) {
                this.optionalStart();

            } else if (cur === &apos;]&apos;) {
                if (this._active._parent === null) {
                    throw new IllegalArgumentException(&apos;Pattern invalid as it contains ] without previous [&apos;);
                }
                this.optionalEnd();

            } else if (cur === &apos;{&apos; || cur === &apos;}&apos; || cur === &apos;#&apos;) {
                throw new IllegalArgumentException(&apos;Pattern includes reserved character: \&apos;&apos; + cur + &apos;\&apos;&apos;);
            } else {
                this.appendLiteral(cur);
            }
        }
    }

    _parseField(cur, count, field) {
        switch (cur) {
            case &apos;u&apos;:
            case &apos;y&apos;:
                if (count === 2) {
                    this.appendValueReduced(field, 2, 2, ReducedPrinterParser.BASE_DATE);
                } else if (count &lt; 4) {
                    this.appendValue(field, count, MAX_WIDTH, SignStyle.NORMAL);
                } else {
                    this.appendValue(field, count, MAX_WIDTH, SignStyle.EXCEEDS_PAD);
                }
                break;
            case &apos;M&apos;:
            case &apos;Q&apos;:
                switch (count) {
                    case 1:
                        this.appendValue(field);
                        break;
                    case 2:
                        this.appendValue(field, 2);
                        break;
                    case 3:
                        //TODO:
                        throw new IllegalArgumentException(&apos;Pattern using (localized) text not implemented yet!&apos;);
                        this.appendText(field, TextStyle.SHORT);
                        break;
                    case 4:
                        //TODO:
                        throw new IllegalArgumentException(&apos;Pattern using (localized) text not implemented yet!&apos;);
                        this.appendText(field, TextStyle.FULL);
                        break;
                    case 5:
                        //TODO:
                        throw new IllegalArgumentException(&apos;Pattern using (localized) text not implemented yet!&apos;);
                        this.appendText(field, TextStyle.NARROW);
                        break;
                    default:
                        throw new IllegalArgumentException(&apos;Too many pattern letters: &apos; + cur);
                }
                break;
            case &apos;L&apos;:
            case &apos;q&apos;:
                switch (count) {
                    case 1:
                        this.appendValue(field);
                        break;
                    case 2:
                        this.appendValue(field, 2);
                        break;
                    case 3:
                        //TODO:
                        throw new IllegalArgumentException(&apos;Pattern using (localized) text not implemented yet!&apos;);
                        this.appendText(field, TextStyle.SHORT_STANDALONE);
                        break;
                    case 4:
                        //TODO:
                        throw new IllegalArgumentException(&apos;Pattern using (localized) text not implemented yet!&apos;);
                        this.appendText(field, TextStyle.FULL_STANDALONE);
                        break;
                    case 5:
                        //TODO:
                        throw new IllegalArgumentException(&apos;Pattern using (localized) text not implemented yet!&apos;);
                        this.appendText(field, TextStyle.NARROW_STANDALONE);
                        break;
                    default:
                        throw new IllegalArgumentException(&apos;Too many pattern letters: &apos; + cur);
                }
                break;
            case &apos;e&apos;:
                switch (count) {
                    case 1:
                    case 2:
                        // TODO: WeekFieldsPrinterParser
                        throw new IllegalArgumentException(&apos;Pattern using WeekFields not implemented yet!&apos;);
                        // this.appendInternal(new WeekFieldsPrinterParser(&apos;e&apos;, count));
                        break;
                    case 3:
                        //TODO:
                        throw new IllegalArgumentException(&apos;Pattern using (localized) text not implemented yet!&apos;);
                        this.appendText(field, TextStyle.SHORT);
                        break;
                    case 4:
                        //TODO:
                        throw new IllegalArgumentException(&apos;Pattern using (localized) text not implemented yet!&apos;);
                        this.appendText(field, TextStyle.FULL);
                        break;
                    case 5:
                        //TODO:
                        throw new IllegalArgumentException(&apos;Pattern using (localized) text not implemented yet!&apos;);
                        this.appendText(field, TextStyle.NARROW);
                        break;
                    default:
                        throw new IllegalArgumentException(&apos;Too many pattern letters: &apos; + cur);
                }
                break;
            case &apos;c&apos;:
                switch (count) {
                    case 1:
                        // TODO: WeekFieldsPrinterParser
                        throw new IllegalArgumentException(&apos;Pattern using WeekFields not implemented yet!&apos;);
                        // this.appendInternal(new WeekFieldsPrinterParser(&apos;c&apos;, count));
                        break;
                    case 2:
                        throw new IllegalArgumentException(&apos;Invalid number of pattern letters: &apos; + cur);
                    case 3:
                        //TODO:
                        throw new IllegalArgumentException(&apos;Pattern using (localized) text not implemented yet!&apos;);
                        this.appendText(field, TextStyle.SHORT_STANDALONE);
                        break;
                    case 4:
                        //TODO:
                        throw new IllegalArgumentException(&apos;Pattern using (localized) text not implemented yet!&apos;);
                        this.appendText(field, TextStyle.FULL_STANDALONE);
                        break;
                    case 5:
                        //TODO:
                        throw new IllegalArgumentException(&apos;Pattern using (localized) text not implemented yet!&apos;);
                        this.appendText(field, TextStyle.NARROW_STANDALONE);
                        break;
                    default:
                        throw new IllegalArgumentException(&apos;Too many pattern letters: &apos; + cur);
                }
                break;
            case &apos;a&apos;:
                if (count === 1) {
                    //TODO:
                    throw new IllegalArgumentException(&apos;Pattern using (localized) text not implemented yet!&apos;);
                    this.appendText(field, TextStyle.SHORT);
                } else {
                    throw new IllegalArgumentException(&apos;Too many pattern letters: &apos; + cur);
                }
                break;
            case &apos;E&apos;:
            case &apos;G&apos;:
                switch (count) {
                    case 1:
                    case 2:
                    case 3:
                        //TODO:
                        throw new IllegalArgumentException(&apos;Pattern using (localized) text not implemented yet!&apos;);
                        this.appendText(field, TextStyle.SHORT);
                        break;
                    case 4:
                        //TODO:
                        throw new IllegalArgumentException(&apos;Pattern using (localized) text not implemented yet!&apos;);
                        this.appendText(field, TextStyle.FULL);
                        break;
                    case 5:
                        //TODO:
                        throw new IllegalArgumentException(&apos;Pattern using (localized) text not implemented yet!&apos;);
                        this.appendText(field, TextStyle.NARROW);
                        break;
                    default:
                        throw new IllegalArgumentException(&apos;Too many pattern letters: &apos; + cur);
                }
                break;
            case &apos;S&apos;:
                this.appendFraction(ChronoField.NANO_OF_SECOND, count, count, false);
                break;
            case &apos;F&apos;:
                if (count === 1) {
                    this.appendValue(field);
                } else {
                    throw new IllegalArgumentException(&apos;Too many pattern letters: &apos; + cur);
                }
                break;
            case &apos;d&apos;:
            case &apos;h&apos;:
            case &apos;H&apos;:
            case &apos;k&apos;:
            case &apos;K&apos;:
            case &apos;m&apos;:
            case &apos;s&apos;:
                if (count === 1) {
                    this.appendValue(field);
                } else if (count === 2) {
                    this.appendValue(field, count);
                } else {
                    throw new IllegalArgumentException(&apos;Too many pattern letters: &apos; + cur);
                }
                break;
            case &apos;D&apos;:
                if (count === 1) {
                    this.appendValue(field);
                } else if (count &lt;= 3) {
                    this.appendValue(field, count);
                } else {
                    throw new IllegalArgumentException(&apos;Too many pattern letters: &apos; + cur);
                }
                break;
            default:
                if (count === 1) {
                    this.appendValue(field);
                } else {
                    this.appendValue(field, count);
                }
                break;
        }
    }

    /**
     * padNext function overloading
     */
    padNext() {
        if (arguments.length === 1) {
            return this._padNext1.apply(this, arguments);
        } else {
            return this._padNext2.apply(this, arguments);
        }
    }

    /**
     * Causes the next added printer/parser to pad to a fixed width using a space.
     * &lt;p&gt;
     * This padding will pad to a fixed width using spaces.
     * &lt;p&gt;
     * During formatting, the decorated element will be output and then padded
     * to the specified width. An exception will be thrown during printing if
     * the pad width is exceeded.
     * &lt;p&gt;
     * During parsing, the padding and decorated element are parsed.
     * If parsing is lenient, then the pad width is treated as a maximum.
     * If parsing is case insensitive, then the pad character is matched ignoring case.
     * The padding is parsed greedily. Thus, if the decorated element starts with
     * the pad character, it will not be parsed.
     *
     * @param {number} padWidth  the pad width, 1 or greater
     * @return {DateTimeFormatterBuilder} this, for chaining, not null
     * @throws IllegalArgumentException if pad width is too small
     */
    _padNext1(padWidth) {
        return this._padNext2(padWidth, &apos; &apos;);
    }

    /**
     * Causes the next added printer/parser to pad to a fixed width.
     * &lt;p&gt;
     * This padding is intended for padding other than zero-padding.
     * Zero-padding should be achieved using the appendValue methods.
     * &lt;p&gt;
     * During formatting, the decorated element will be output and then padded
     * to the specified width. An exception will be thrown during printing if
     * the pad width is exceeded.
     * &lt;p&gt;
     * During parsing, the padding and decorated element are parsed.
     * If parsing is lenient, then the pad width is treated as a maximum.
     * If parsing is case insensitive, then the pad character is matched ignoring case.
     * The padding is parsed greedily. Thus, if the decorated element starts with
     * the pad character, it will not be parsed.
     *
     * @param {number} padWidth  the pad width, 1 or greater
     * @param {String} padChar  the pad character
     * @return {DateTimeFormatterBuilder} this, for chaining, not null
     * @throws IllegalArgumentException if pad width is too small
     */
    _padNext2(padWidth, padChar) {
        if (padWidth &lt; 1) {
            throw new IllegalArgumentException(&apos;The pad width must be at least one but was &apos; + padWidth);
        }
        this._active._padNextWidth = padWidth;
        this._active._padNextChar = padChar;
        this._active._valueParserIndex = -1;
        return this;
    }


    //-----------------------------------------------------------------------
    /**
     * Mark the start of an optional section.
     * &lt;p&gt;
     * The output of printing can include optional sections, which may be nested.
     * An optional section is started by calling this method and ended by calling
     * {@link #optionalEnd()} or by ending the build process.
     * &lt;p&gt;
     * All elements in the optional section are treated as optional.
     * During printing, the section is only output if data is available in the
     * {@code TemporalAccessor} for all the elements in the section.
     * During parsing, the whole section may be missing from the parsed string.
     * &lt;p&gt;
     * For example, consider a builder setup as
     * {@code builder.appendValue(HOUR_OF_DAY,2).optionalStart().appendValue(MINUTE_OF_HOUR,2)}.
     * The optional section ends automatically at the end of the builder.
     * During printing, the minute will only be output if its value can be obtained from the date-time.
     * During parsing, the input will be successfully parsed whether the minute is present or not.
     *
     * @return {DateTimeFormatterBuilder} this, for chaining, not null
     */
    optionalStart() {
        this._active._valueParserIndex = -1;
        this._active = new DateTimeFormatterBuilder(this._active, true);
        return this;
    }

    /**
     * Ends an optional section.
     * &lt;p&gt;
     * The output of printing can include optional sections, which may be nested.
     * An optional section is started by calling {@link #optionalStart()} and ended
     * using this method (or at the end of the builder).
     * &lt;p&gt;
     * Calling this method without having previously called {@code optionalStart}
     * will throw an exception.
     * Calling this method immediately after calling {@code optionalStart} has no effect
     * on the formatter other than ending the (empty) optional section.
     * &lt;p&gt;
     * All elements in the optional section are treated as optional.
     * During printing, the section is only output if data is available in the
     * {@code TemporalAccessor} for all the elements in the section.
     * During parsing, the whole section may be missing from the parsed string.
     * &lt;p&gt;
     * For example, consider a builder setup as
     * {@code builder.appendValue(HOUR_OF_DAY,2).optionalStart().appendValue(MINUTE_OF_HOUR,2).optionalEnd()}.
     * During printing, the minute will only be output if its value can be obtained from the date-time.
     * During parsing, the input will be successfully parsed whether the minute is present or not.
     *
     * @return {DateTimeFormatterBuilder} this, for chaining, not null
     * @throws IllegalStateException if there was no previous call to {@code optionalStart}
     */
    optionalEnd() {
        if (this._active._parent == null) {
            throw new IllegalStateException(&apos;Cannot call optionalEnd() as there was no previous call to optionalStart()&apos;);
        }
        if (this._active._printerParsers.length &gt; 0) {
            var cpp = new CompositePrinterParser(this._active._printerParsers, this._active._optional);
            this._active = this._active._parent;
            this._appendInternal(cpp);
        } else {
            this._active = this._active._parent;
        }
        return this;
    }

    /**
     * Appends a printer and/or parser to the internal list handling padding.
     *
     * @param pp  the printer-parser to add, not null
     * @return the index into the active parsers list
     */
    _appendInternal(pp) {
        assert(pp != null);
        if (this._active._padNextWidth &gt; 0) {
            if (pp != null) {
                pp = new PadPrinterParserDecorator(pp, this._active._padNextWidth, this._active._padNextChar);
            }
            this._active._padNextWidth = 0;
            this._active._padNextChar = 0;
        }
        this._active._printerParsers.push(pp);
        this._active._valueParserIndex = -1;
        return this._active._printerParsers.length - 1;
    }

    /**
     * Appends a string literal to the formatter.
     * 
     * This string will be output during a print.
     * 
     * If the literal is empty, nothing is added to the formatter.
     *
     * @param literal  the literal to append, not null
     * @return {DateTimeFormatterBuilder} this, for chaining, not null
     */
    appendLiteral(literal) {
        assert(literal != null);
        if (literal.length &gt; 0) {
            if (literal.length === 1) {
                this._appendInternalPrinterParser(new CharLiteralPrinterParser(literal.charAt(0)));
            } else {
                this._appendInternalPrinterParser(new StringLiteralPrinterParser(literal));
            }
        }
        return this;
    }
    
    /**
     * Appends a printer and/or parser to the internal list handling padding.
     *
     * @param pp  the printer-parser to add, not null
     * @return the index into the active parsers list
     */
    _appendInternalPrinterParser(pp) {
        assert(pp != null);
        if (this._active._padNextWidth &gt; 0) {
            if (pp != null) {
                pp = new PadPrinterParserDecorator(pp, this._active._padNextWidth, this._active._padNextChar);
            }
            this._active._padNextWidth = 0;
            this._active._padNextChar = 0;
        }
        this._active._printerParsers.push(pp);
        this._active._valueParserIndex = -1;
        return this._active._printerParsers.length - 1;
    }
    
    //-----------------------------------------------------------------------
    /**
     * Appends all the elements of a formatter to the builder.
     * &lt;p&gt;
     * This method has the same effect as appending each of the constituent
     * parts of the formatter directly to this builder.
     *
     * @param {DateTimeFormatter} formatter  the formatter to add, not null
     * @return {DateTimeFormatterBuilder} this, for chaining, not null
     */
    append(formatter) {
        requireNonNull(formatter, &apos;formatter&apos;);
        this._appendInternal(formatter.toPrinterParser(false));
        return this;
    }

    /**
     * Completes this builder by creating the DateTimeFormatter.
     * 
     * This will create a formatter with the specified locale.
     * Numbers will be printed and parsed using the standard non-localized set of symbols.
     * 
     * Calling this method will end any open optional sections by repeatedly
     * calling {@link #optionalEnd()} before creating the formatter.
     * 
     * This builder can still be used after creating the formatter if desired,
     * although the state may have been changed by calls to {@code optionalEnd}.
     *
     * @param resolverStyle  the new resolver style
     * @return the created formatter, not null
     */
    toFormatter(resolverStyle=ResolverStyle.SMART) {
        while (this._active._parent != null) {
            this.optionalEnd();
        }
        var pp = new CompositePrinterParser(this._printerParsers, false);
        return new DateTimeFormatter(pp, null, DecimalStyle.STANDARD, resolverStyle, null, null, null);
    }

}

const EXCEED_POINTS = [
    0,
    10,
    100,
    1000,
    10000,
    100000,
    1000000,
    10000000,
    100000000,
    1000000000
];

class CompositePrinterParser {

    constructor(printerParsers, optional) {
        this._printerParsers = printerParsers;
        this._optional = optional;
    }

    /**
     * Returns a copy of this printer-parser with the optional flag changed.
     *
     * @param {boolean} optional  the optional flag to set in the copy
     * @return {CompositePrinterParser} the new printer-parser, not null
     */
    withOptional(optional) {
        if (optional === this._optional) {
            return this;
        }
        return new CompositePrinterParser(this._printerParsers, optional);
    }

    print(context, buf) {
        var length = buf.length();
        if (this._optional) {
            context.startOptional();
        }
        try {
            for (let i=0; i&lt;this._printerParsers.length; i++) {
                let pp = this._printerParsers[i];
                if (pp.print(context, buf) === false) {
                    buf.setLength(length);  // reset buffer
                    return true;
                }
            }
        } finally {
            if (this._optional) {
                context.endOptional();
            }
        }
        return true;
    }

    parse(context, text, position) {
        if (this._optional) {
            context.startOptional();
            var pos = position;
            for (let i=0; i&lt;this._printerParsers.length; i++) {
                let pp = this._printerParsers[i];
                pos = pp.parse(context, text, pos);
                if (pos &lt; 0) {
                    context.endOptional(false);
                    return position;  // return original position
                }
            }
            context.endOptional(true);
            return pos;
        } else {
            for (let i=0; i&lt;this._printerParsers.length; i++) {
                let pp = this._printerParsers[i];
                position = pp.parse(context, text, position);
                if (position &lt; 0) {
                    break;
                }
            }
            return position;
        }
    }

    toString() {
        var buf = &apos;&apos;;
        if (this._printerParsers != null) {
            buf += this._optional ? &apos;[&apos; : &apos;(&apos;;
            for (let i=0; i&lt;this._printerParsers.length; i++) {
                let pp = this._printerParsers[i];
                buf += pp.toString();
            }
            buf += this._optional ? &apos;]&apos; : &apos;)&apos;;
        }
        return buf;
    }
}

/**
 * Pads the output to a fixed width.
 */
class PadPrinterParserDecorator {

    /**
     * Constructor.
     *
     * @param printerParser  the printer, not null
     * @param padWidth  the width to pad to, 1 or greater
     * @param padChar  the pad character
     */
    constructor(printerParser, padWidth, padChar) {
        // input checked by DateTimeFormatterBuilder
        this._printerParser = printerParser;
        this._padWidth = padWidth;
        this._padChar = padChar;
    }

    print(context, buf) {
        var preLen = buf.length();
        if (this._printerParser.print(context, buf) === false) {
            return false;
        }
        var len = buf.length() - preLen;
        if (len &gt; this._padWidth) {
            throw new DateTimeException(
                `Cannot print as output of ${len} characters exceeds pad width of ${this._padWidth}`);
        }
        for (let i = 0; i &lt; this._padWidth - len; i++) {
            buf.insert(preLen, this._padChar);
        }
        return true;
    }

    parse(context, text, position) {
        // cache context before changed by decorated parser
        var strict = context.isStrict();
        var caseSensitive = context.isCaseSensitive();
        // parse
        assert(!(position &gt; text.length));
        assert(position &gt;= 0);
        if (position === text.length) {
            return ~position;  // no more characters in the string
        }
        var endPos = position + this._padWidth;
        if (endPos &gt; text.length) {
            if (strict) {
                return ~position;  // not enough characters in the string to meet the parse width
            }
            endPos = text.length;
        }
        var pos = position;
        while (pos &lt; endPos &amp;&amp;
                (caseSensitive ? text[pos] === this._padChar : context.charEquals(text[pos], this._padChar))) {
            pos++;
        }
        text = text.substring(0, endPos);
        var resultPos = this._printerParser.parse(context, text, pos);
        if (resultPos !== endPos &amp;&amp; strict) {
            return ~(position + pos);  // parse of decorated field didn&apos;t parse to the end
        }
        return resultPos;
    }

    toString() {
        return `Pad(${this._printerParser},${this._padWidth}${(this._padChar === &apos; &apos; ? &apos;)&apos; : &apos;,\&apos;&apos; + this._padChar + &apos;\&apos;)&apos;)}`;
    }
}

class SettingsParser extends Enum {

    print(/*context, buf*/) {
        return true;  // nothing to do here
    }

    parse(context, text, position) {
        // using ordinals to avoid javac synthetic inner class
        switch (this) {
            case SettingsParser.SENSITIVE:   context.setCaseSensitive(true); break;
            case SettingsParser.INSENSITIVE: context.setCaseSensitive(false); break;
            case SettingsParser.STRICT:      context.setStrict(true); break;
            case SettingsParser.LENIENT:     context.setStrict(false); break;
        }
        return position;
    }

    toString() {
        // using ordinals to avoid javac synthetic inner class
        switch (this) {
            case SettingsParser.SENSITIVE:   return &apos;ParseCaseSensitive(true)&apos;;
            case SettingsParser.INSENSITIVE: return &apos;ParseCaseSensitive(false)&apos;;
            case SettingsParser.STRICT:      return &apos;ParseStrict(true)&apos;;
            case SettingsParser.LENIENT:     return &apos;ParseStrict(false)&apos;;
        }
    }
}

SettingsParser.SENSITIVE = new SettingsParser(&apos;SENSITIVE&apos;);
SettingsParser.INSENSITIVE = new SettingsParser(&apos;INSENSITIVE&apos;);
SettingsParser.STRICT = new SettingsParser(&apos;STRICT&apos;);
SettingsParser.LENIENT = new SettingsParser(&apos;LENIENT&apos;);

/**
* Prints or parses a string literal.
*/
class StringLiteralPrinterParser {

    constructor(literal) {
        this._literal = literal;
    }

    print(context, buf) {
        buf.append(this._literal);
        return true;
    }

    parse(context, text, position) {
        var length = text.length;
        assert(!(position &gt; length || position &lt; 0));

        if (context.subSequenceEquals(text, position, this._literal, 0, this._literal.length) === false) {
            return ~position;
        }
        return position + this._literal.length;
    }

    toString() {
        let converted = this._literal.replace(&quot;&apos;&quot;, &quot;&apos;&apos;&quot;);
        return &apos;\&apos;&apos; + converted + &apos;\&apos;&apos;;
    }
}

/**
 * Prints or parses a char literal.
 */
class CharLiteralPrinterParser {

    constructor(literal) {
        if (literal.length &gt; 1) {
            throw new IllegalArgumentException(&apos;invalid literal, too long: &quot;&apos; + literal + &apos;&quot;&apos;);
        }
        this._literal = literal;
    }

    print(context, buf) {
        buf.append(this._literal);
        return true;
    }

    parse(context, text, position) {
        var length = text.length;
        if (position === length) {
            return ~position;
        }
        let ch = text.charAt(position);
        if (context.charEquals(this._literal, ch) === false) {
            return ~position;
        }
        return position + this._literal.length;
    }

    toString() {
        if (this._literal === &apos;\&apos;&apos;) {
            return &quot;&apos;&apos;&quot;;
        }
        return &quot;&apos;&quot; + this._literal + &quot;&apos;&quot;;
    }
}

class NumberPrinterParser {

    /**
     * Constructor.
     *
     * @param field  the field to print, not null
     * @param minWidth  the minimum field width, from 1 to 19
     * @param maxWidth  the maximum field width, from minWidth to 19
     * @param signStyle  the positive/negative sign style, not null
     * @param subsequentWidth  the width of subsequent non-negative numbers, 0 or greater,
     *  -1 if fixed width due to active adjacent parsing
     */
    constructor(field, minWidth, maxWidth, signStyle, subsequentWidth=0){
        this._field = field;
        this._minWidth = minWidth;
        this._maxWidth = maxWidth;
        this._signStyle = signStyle;
        this._subsequentWidth = subsequentWidth;
    }

    field(){ return this._field;}
    minWidth(){ return this._minWidth;}
    maxWidth(){ return this._maxWidth;}
    signStyle(){ return this._signStyle;}

    withSubsequentWidth(subsequentWidth) {
        return new NumberPrinterParser(this._field, this._minWidth, this._maxWidth, this._signStyle, this._subsequentWidth + subsequentWidth);
    }

    _isFixedWidth() {
        return this._subsequentWidth === -1 ||
                (this._subsequentWidth &gt; 0 &amp;&amp; this._minWidth === this._maxWidth &amp;&amp; this._signStyle === SignStyle.NOT_NEGATIVE);
    }

    print(context, buf) {
        var value = context.getValue(this._field);
        if (value == null) {
            return false;
        }
        var symbols = context.symbols();
        var str = &apos;&apos; + Math.abs(value);
        if (str.length &gt; this._maxWidth) {
            throw new DateTimeException(&apos;Field &apos; + this._field +
                &apos; cannot be printed as the value &apos; + value +
                &apos; exceeds the maximum print width of &apos; + this._maxWidth);
        }
        str = symbols.convertNumberToI18N(str);

        if (value &gt;= 0) {
            switch (this._signStyle) {
                case SignStyle.EXCEEDS_PAD:
                    if (this._minWidth &lt; MAX_WIDTH &amp;&amp; value &gt;= EXCEED_POINTS[this._minWidth]) {
                        buf.append(symbols.positiveSign());
                    }
                    break;
                case SignStyle.ALWAYS:
                    buf.append(symbols.positiveSign());
                    break;
            }
        } else {
            switch (this._signStyle) {
                case SignStyle.NORMAL:
                case SignStyle.EXCEEDS_PAD:
                case SignStyle.ALWAYS:
                    buf.append(symbols.negativeSign());
                    break;
                case SignStyle.NOT_NEGATIVE:
                    throw new DateTimeException(&apos;Field &apos; + this._field +
                        &apos; cannot be printed as the value &apos; + value +
                        &apos; cannot be negative according to the SignStyle&apos;);
            }
        }
        for (let i = 0; i &lt; this._minWidth - str.length; i++) {
            buf.append(symbols.zeroDigit());
        }
        buf.append(str);
        return true;
    }

    parse(context, text, position){
        var length = text.length;
        if (position === length) {
            return ~position;
        }
        assert(position&gt;=0 &amp;&amp; position&lt;length);
        var sign = text.charAt(position);  // IOOBE if invalid position
        var negative = false;
        var positive = false;
        if (sign === context.symbols().positiveSign()) {
            if (this._signStyle.parse(true, context.isStrict(), this._minWidth === this._maxWidth) === false) {
                return ~position;
            }
            positive = true;
            position++;
        } else if (sign === context.symbols().negativeSign()) {
            if (this._signStyle.parse(false, context.isStrict(), this._minWidth === this._maxWidth) === false) {
                return ~position;
            }
            negative = true;
            position++;
        } else {
            if (this._signStyle === SignStyle.ALWAYS &amp;&amp; context.isStrict()) {
                return ~position;
            }
        }
        var effMinWidth = (context.isStrict() || this._isFixedWidth() ? this._minWidth : 1);
        var minEndPos = position + effMinWidth;
        if (minEndPos &gt; length) {
            return ~position;
        }
        var effMaxWidth = (context.isStrict() || this._isFixedWidth() ? this._maxWidth : 9) + Math.max(this._subsequentWidth, 0);
        var total = 0;
        var pos = position;
        for (let pass = 0; pass &lt; 2; pass++) {
            let maxEndPos = Math.min(pos + effMaxWidth, length);
            while (pos &lt; maxEndPos) {
                let ch = text.charAt(pos++);
                let digit = context.symbols().convertToDigit(ch);
                if (digit &lt; 0) {
                    pos--;
                    if (pos &lt; minEndPos) {
                        return ~position;  // need at least min width digits
                    }
                    break;
                }
                if ((pos - position) &gt; MAX_WIDTH) {
                    throw new ArithmeticException(&apos;number text exceeds length&apos;);
                } else {
                    total = total * 10 + digit;
                }
            }
            if (this._subsequentWidth &gt; 0 &amp;&amp; pass === 0) {
                // re-parse now we know the correct width
                let parseLen = pos - position;
                effMaxWidth = Math.max(effMinWidth, parseLen - this._subsequentWidth);
                pos = position;
                total = 0;
            } else {
                break;
            }
        }
        if (negative) {
            if (total === 0 &amp;&amp; context.isStrict()) {
                return ~(position - 1);  // minus zero not allowed
            }
            if(total !== 0) {
                total = -total;
            }
        } else if (this._signStyle === SignStyle.EXCEEDS_PAD &amp;&amp; context.isStrict()) {
            let parseLen = pos - position;
            if (positive) {
                if (parseLen &lt;= this._minWidth) {
                    return ~(position - 1);  // &apos;+&apos; only parsed if minWidth exceeded
                }
            } else {
                if (parseLen &gt; this._minWidth) {
                    return ~position;  // &apos;+&apos; must be parsed if minWidth exceeded
                }
            }
        }
        return this._setValue(context, total, position, pos);
    }

    /**
     * Stores the value.
     *
     * @param context  the context to store into, not null
     * @param value  the value
     * @param errorPos  the position of the field being parsed
     * @param successPos  the position after the field being parsed
     * @return the new position
     */
    _setValue(context, value, errorPos, successPos) {
        return context.setParsedField(this._field, value, errorPos, successPos);
    }

    toString() {
        if (this._minWidth === 1 &amp;&amp; this._maxWidth === MAX_WIDTH &amp;&amp; this._signStyle === SignStyle.NORMAL) {
            return &apos;Value(&apos; + this._field + &apos;)&apos;;
        }
        if (this._minWidth === this._maxWidth &amp;&amp; this._signStyle === SignStyle.NOT_NEGATIVE) {
            return &apos;Value(&apos; + this._field + &apos;,&apos; + this._minWidth + &apos;)&apos;;
        }
        return &apos;Value(&apos; + this._field + &apos;,&apos; + this._minWidth + &apos;,&apos; + this._maxWidth + &apos;,&apos; + this._signStyle + &apos;)&apos;;
    }

}
//-----------------------------------------------------------------------
/**
 * Prints and parses a reduced numeric date-time field.
 */
class ReducedPrinterParser extends NumberPrinterParser {

    /**
     * Constructor.
     *
     * @param {TemporalField} field  the field to print, validated not null
     * @param {number} width  the field width, from 1 to 10
     * @param {number} maxWidth  the field max width, from 1 to 10
     * @param {number} baseValue  the base value
     * @param {ChronoLocalDate} baseDate  the base date
     */
    constructor(field, width, maxWidth, baseValue, baseDate) {
        super(field, width, maxWidth, SignStyle.NOT_NEGATIVE);
        if (width &lt; 1 || width &gt; 10) {
            throw new IllegalArgumentException(&apos;The width must be from 1 to 10 inclusive but was &apos; + width);
        }
        if (maxWidth &lt; 1 || maxWidth &gt; 10) {
            throw new IllegalArgumentException(&apos;The maxWidth must be from 1 to 10 inclusive but was &apos; + maxWidth);
        }
        if (maxWidth &lt; width) {
            throw new IllegalArgumentException(&apos;The maxWidth must be greater than the width&apos;);
        }
        if (baseDate === null) {
            if (field.range().isValidValue(baseValue) === false) {
                throw new IllegalArgumentException(&apos;The base value must be within the range of the field&apos;);
            }
            if ((baseValue + EXCEED_POINTS[width]) &gt; MathUtil.MAX_SAFE_INTEGER) {
                throw new DateTimeException(&apos;Unable to add printer-parser as the range exceeds the capacity of an int&apos;);
            }
        }
        this._baseValue = baseValue;
        this._baseDate = baseDate;
    }

    /**
     *
     * @param {DateTimePrintContext} context
     * @param {number} value
     */
    getValue(context, value) {
        let absValue = Math.abs(value);
        let baseValue = this._baseValue;
        if (this._baseDate !== null) {
            // TODO: in threetenbp the following line is used, but we dont have Chronology yet, 
            // let chrono = Chronology.from(context.getTemporal());
            // so let&apos;s use IsoChronology for now
            context.temporal();
            let chrono = IsoChronology.INSTANCE;
            baseValue = chrono.date(this._baseDate).get(this._field);
        }
        if (value &gt;= baseValue &amp;&amp; value &lt; baseValue + EXCEED_POINTS[this._minWidth]) {
            return absValue % EXCEED_POINTS[this._minWidth];
        }
        return absValue % EXCEED_POINTS[this._maxWidth];
    }

    /**
     *
     * @param {DateTimeParseContext} context
     * @param {number} value
     * @param {number} errorPos
     * @param {number} successPos
     */
    setValue(context, value, errorPos, successPos) {
        let baseValue = this._baseValue;
        if (this._baseDate != null) {
            let chrono = context.getEffectiveChronology();
            baseValue = chrono.date(this._baseDate).get(this._field);
            context.addChronologyChangedParser(this, value, errorPos, successPos);
        }
        let parseLen = successPos - errorPos;
        if (parseLen === this._minWidth &amp;&amp; value &gt;= 0) {
            let range = EXCEED_POINTS[this._minWidth];
            let lastPart = baseValue % range;
            let basePart = baseValue - lastPart;
            if (baseValue &gt; 0) {
                value = basePart + value;
            } else {
                value = basePart - value;
            }
            if (value &lt; baseValue) {
                value += range;
            }
        }
        return context.setParsedField(this._field, value, errorPos, successPos);
    }

    withFixedWidth() {
        if (this.subsequentWidth() === -1) {
            return this;
        }
        return new ReducedPrinterParser(this._field, this._minWidth, this._maxWidth, this._baseValue, this._baseDate, -1);
    }

    /**
     *
     * @param {number} subsequentWidth
     * @returns {ReducedPrinterParser}
     */
    withSubsequentWidth(subsequentWidth) {
        return new ReducedPrinterParser(this._field, this._minWidth, this._maxWidth, this._baseValue, this._baseDate,
            this._subsequentWidth + subsequentWidth);
    }

    /**
     *
     * @param {DateTimeParseContext} context
     */
    isFixedWidth(context) {
        if (context.isStrict() === false) {
            return false;
        }
        return super.isFixedWidth(context);
    }

    toString() {
        return &apos;ReducedValue(&apos; + this._field + &apos;,&apos; + this._minWidth + &apos;,&apos; + this._maxWidth + &apos;,&apos; + (this._baseDate != null ? this._baseDate : this._baseValue) + &apos;)&apos;;
    }
}


//-----------------------------------------------------------------------

/**
 * TODO optimize FractionPrinterParser, fix documentation
 *
 * Prints and parses a numeric date-time field with optional padding.
 */
class FractionPrinterParser {

    /**
     * Constructor.
     *
     * @param {TemporalField} field  the field to output, not null
     * @param {Number} minWidth  the minimum width to output, from 0 to 9
     * @param {Number} maxWidth  the maximum width to output, from 0 to 9
     * @param {boolean} decimalPoint  whether to output the localized decimal point symbol
     */
    constructor(field, minWidth, maxWidth, decimalPoint) {
        requireNonNull(field, &apos;field&apos;);
        if (field.range().isFixed() === false) {
            throw new IllegalArgumentException(&apos;Field must have a fixed set of values: &apos; + field);
        }
        if (minWidth &lt; 0 || minWidth &gt; 9) {
            throw new IllegalArgumentException(&apos;Minimum width must be from 0 to 9 inclusive but was &apos; + minWidth);
        }
        if (maxWidth &lt; 1 || maxWidth &gt; 9) {
            throw new IllegalArgumentException(&apos;Maximum width must be from 1 to 9 inclusive but was &apos; + maxWidth);
        }
        if (maxWidth &lt; minWidth) {
            throw new IllegalArgumentException(&apos;Maximum width must exceed or equal the minimum width but &apos; +
                    maxWidth + &apos; &lt; &apos; + minWidth);
        }
        this.field = field;
        this.minWidth = minWidth;
        this.maxWidth = maxWidth;
        this.decimalPoint = decimalPoint;
    }

    print(context, buf) {
        var value = context.getValue(this.field);
        if (value === null) {
            return false;
        }
        var symbols = context.symbols();
        if (value === 0) {  // scale is zero if value is zero
            if (this.minWidth &gt; 0) {
                if (this.decimalPoint) {
                    buf.append(symbols.decimalSeparator());
                }
                for (let i = 0; i &lt; this.minWidth; i++) {
                    buf.append(symbols.zeroDigit());
                }
            }
        } else {
            var fraction = this.convertToFraction(value, symbols.zeroDigit());
            var outputScale = Math.min(Math.max(fraction.length, this.minWidth), this.maxWidth);
            fraction = fraction.substr(0, outputScale);
            if(fraction * 1 &gt; 0 ) {
                while (fraction.length &gt; this.minWidth &amp;&amp; fraction[fraction.length - 1] === &apos;0&apos;) {
                    fraction = fraction.substr(0, fraction.length - 1);
                }
            }
            var str = fraction;
            str = symbols.convertNumberToI18N(str);
            if (this.decimalPoint) {
                buf.append(symbols.decimalSeparator());
            }
            buf.append(str);
        }
        return true;
    }

    parse(context, text, position) {
        var effectiveMin = (context.isStrict() ? this.minWidth : 0);
        var effectiveMax = (context.isStrict() ? this.maxWidth : 9);
        var length = text.length;
        if (position === length) {
            // valid if whole field is optional, invalid if minimum width
            return (effectiveMin &gt; 0 ? ~position : position);
        }
        if (this.decimalPoint) {
            if (text[position] !== context.symbols().decimalSeparator()) {
                // valid if whole field is optional, invalid if minimum width
                return (effectiveMin &gt; 0 ? ~position : position);
            }
            position++;
        }
        var minEndPos = position + effectiveMin;
        if (minEndPos &gt; length) {
            return ~position;  // need at least min width digits
        }
        var maxEndPos = Math.min(position + effectiveMax, length);
        var total = 0;  // can use int because we are only parsing up to 9 digits
        var pos = position;
        while (pos &lt; maxEndPos) {
            var ch = text.charAt(pos++);
            var digit = context.symbols().convertToDigit(ch);
            if (digit &lt; 0) {
                if (pos &lt; minEndPos) {
                    return ~position;  // need at least min width digits
                }
                pos--;
                break;
            }
            total = total * 10 + digit;
        }
        var moveLeft = pos - position;
        var scale = Math.pow(10, moveLeft);
        var value = this.convertFromFraction(total, scale);
        return context.setParsedField(this.field, value, position, pos);
    }

    /**
     *
     * @param {Number} value  the value to convert, must be valid for this rule
     * @return {String} the value as a fraction within the range, from 0 to 1, not null
     */
    convertToFraction(value, zeroDigit) {
        var range = this.field.range();
        range.checkValidValue(value, this.field);
        var _min = range.minimum();
        var _range = range.maximum() - _min + 1;
        var _value = value - _min;
        var _scaled = MathUtil.intDiv((_value * 1000000000),  _range);
        var fraction = &apos;&apos; + _scaled;
        while(fraction.length &lt; 9){
            fraction = zeroDigit + fraction;
        }
        return fraction;
    }

    /**
     *
     * @param {Number} fraction  the fraction to convert, not null
     * @return {Number} the value of the field, valid for this rule
     * @throws DateTimeException if the value cannot be converted
     */
    convertFromFraction(total, scale) {
        var range = this.field.range();
        var _min = range.minimum();
        var _range = range.maximum() - _min + 1;
        var _value = MathUtil.intDiv((total * _range), scale);
        return _value;
    }

    toString() {
        var decimal = (this.decimalPoint ? &apos;,DecimalPoint&apos; : &apos;&apos;);
        return &apos;Fraction(&apos; + this.field + &apos;,&apos; + this.minWidth + &apos;,&apos; + this.maxWidth + decimal + &apos;)&apos;;
    }
}

//-----------------------------------------------------------------------

// days in a 400 year cycle = 146097
// days in a 10,000 year cycle = 146097 * 25
// seconds per day = 86400
const SECONDS_PER_10000_YEARS = 146097 * 25 * 86400;
const SECONDS_0000_TO_1970 = ((146097 * 5) - (30 * 365 + 7)) * 86400;

/**
 * Prints or parses an ISO-8601 instant.
 */
class InstantPrinterParser  {

    constructor(fractionalDigits) {
        this.fractionalDigits = fractionalDigits;
    }

    print(context, buf) {
        // use INSTANT_SECONDS, thus this code is not bound by Instant.MAX
        var inSecs = context.getValue(ChronoField.INSTANT_SECONDS);
        var inNanos = 0;
        if (context.temporal().isSupported(ChronoField.NANO_OF_SECOND)) {
            inNanos = context.temporal().getLong(ChronoField.NANO_OF_SECOND);
        }
        if (inSecs == null) {
            return false;
        }
        var inSec = inSecs;
        var inNano = ChronoField.NANO_OF_SECOND.checkValidIntValue(inNanos);
        if (inSec &gt;= -SECONDS_0000_TO_1970) {
            // current era
            let zeroSecs = inSec - SECONDS_PER_10000_YEARS + SECONDS_0000_TO_1970;
            let hi = MathUtil.floorDiv(zeroSecs, SECONDS_PER_10000_YEARS) + 1;
            let lo = MathUtil.floorMod(zeroSecs, SECONDS_PER_10000_YEARS);
            let ldt = LocalDateTime.ofEpochSecond(lo - SECONDS_0000_TO_1970, 0, ZoneOffset.UTC);
            if (hi &gt; 0) {
                buf.append(&apos;+&apos;).append(hi);
            }
            buf.append(ldt);
            if (ldt.second() === 0) {
                buf.append(&apos;:00&apos;);
            }
        } else {
            // before current era
            let zeroSecs = inSec + SECONDS_0000_TO_1970;
            let hi = MathUtil.intDiv(zeroSecs, SECONDS_PER_10000_YEARS);
            let lo = MathUtil.intMod(zeroSecs, SECONDS_PER_10000_YEARS);
            let ldt = LocalDateTime.ofEpochSecond(lo - SECONDS_0000_TO_1970, 0, ZoneOffset.UTC);
            let pos = buf.length();
            buf.append(ldt);
            if (ldt.second() === 0) {
                buf.append(&apos;:00&apos;);
            }
            if (hi &lt; 0) {
                if (ldt.year() === -10000) {
                    buf.replace(pos, pos + 2, &apos;&apos; + (hi - 1));
                } else if (lo === 0) {
                    buf.insert(pos, hi);
                } else {
                    buf.insert(pos + 1, Math.abs(hi));
                }
            }
        }
        //fraction
        if (this.fractionalDigits === -2) {
            if (inNano !== 0) {
                buf.append(&apos;.&apos;);
                if (MathUtil.intMod(inNano, 1000000) === 0) {
                    buf.append((&apos;&apos; + (MathUtil.intDiv(inNano, 1000000) + 1000)).substring(1));
                } else if (MathUtil.intMod(inNano, 1000) === 0) {
                    buf.append((&apos;&apos; + (MathUtil.intDiv(inNano, 1000) + 1000000)).substring(1));
                } else {
                    buf.append((&apos;&apos; + ((inNano) + 1000000000)).substring(1));
                }
            }
        } else if (this.fractionalDigits &gt; 0 || (this.fractionalDigits === -1 &amp;&amp; inNano &gt; 0)) {
            buf.append(&apos;.&apos;);
            let div = 100000000;
            for (let i = 0; ((this.fractionalDigits === -1 &amp;&amp; inNano &gt; 0) || i &lt; this.fractionalDigits); i++) {
                let digit = MathUtil.intDiv(inNano, div);
                buf.append(digit);
                inNano = inNano - (digit * div);
                div = MathUtil.intDiv(div, 10);
            }
        }
        buf.append(&apos;Z&apos;);
        return true;
    }

    parse(context, text, position) {
        // new context to avoid overwriting fields like year/month/day
        var newContext = context.copy();
        var minDigits = (this.fractionalDigits &lt; 0 ? 0 : this.fractionalDigits);
        var maxDigits = (this.fractionalDigits &lt; 0 ? 9 : this.fractionalDigits);
        var parser = new DateTimeFormatterBuilder()
                .append(DateTimeFormatter.ISO_LOCAL_DATE).appendLiteral(&apos;T&apos;)
                .appendValue(ChronoField.HOUR_OF_DAY, 2).appendLiteral(&apos;:&apos;).appendValue(ChronoField.MINUTE_OF_HOUR, 2).appendLiteral(&apos;:&apos;)
                .appendValue(ChronoField.SECOND_OF_MINUTE, 2).appendFraction(ChronoField.NANO_OF_SECOND, minDigits, maxDigits, true).appendLiteral(&apos;Z&apos;)
                .toFormatter().toPrinterParser(false);
        var pos = parser.parse(newContext, text, position);
        if (pos &lt; 0) {
            return pos;
        }
        // parser restricts most fields to 2 digits, so definitely int
        // correctly parsed nano is also guaranteed to be valid
        var yearParsed = newContext.getParsed(ChronoField.YEAR);
        var month = newContext.getParsed(ChronoField.MONTH_OF_YEAR);
        var day = newContext.getParsed(ChronoField.DAY_OF_MONTH);
        var hour = newContext.getParsed(ChronoField.HOUR_OF_DAY);
        var min = newContext.getParsed(ChronoField.MINUTE_OF_HOUR);
        var secVal = newContext.getParsed(ChronoField.SECOND_OF_MINUTE);
        var nanoVal = newContext.getParsed(ChronoField.NANO_OF_SECOND);
        var sec = (secVal != null ? secVal : 0);
        var nano = (nanoVal != null ? nanoVal : 0);
        var year = MathUtil.intMod(yearParsed, 10000);
        var days = 0;
        if (hour === 24 &amp;&amp; min === 0 &amp;&amp; sec === 0 &amp;&amp; nano === 0) {
            hour = 0;
            days = 1;
        } else if (hour === 23 &amp;&amp; min === 59 &amp;&amp; sec === 60) {
            context.setParsedLeapSecond();
            sec = 59;
        }
        var instantSecs;
        try {
            var ldt = LocalDateTime.of(year, month, day, hour, min, sec, 0).plusDays(days);
            instantSecs = ldt.toEpochSecond(ZoneOffset.UTC);
            instantSecs += MathUtil.safeMultiply(MathUtil.intDiv(yearParsed, 10000), SECONDS_PER_10000_YEARS);
        } catch (ex) {
            return ~position;
        }
        var successPos = pos;
        successPos = context.setParsedField(ChronoField.INSTANT_SECONDS, instantSecs, position, successPos);
        return context.setParsedField(ChronoField.NANO_OF_SECOND, nano, position, successPos);
    }

    toString() {
        return &apos;Instant()&apos;;
    }
}

//-----------------------------------------------------------------------
const PATTERNS = [
    &apos;+HH&apos;, &apos;+HHmm&apos;, &apos;+HH:mm&apos;, &apos;+HHMM&apos;, &apos;+HH:MM&apos;, &apos;+HHMMss&apos;, &apos;+HH:MM:ss&apos;, &apos;+HHMMSS&apos;, &apos;+HH:MM:SS&apos;
];
/**
 * Prints or parses an offset ID.
 */
class OffsetIdPrinterParser  {

    /**
     * Constructor.
     *
     * @param {string} noOffsetText  the text to use for UTC, not null
     * @param {string} pattern  the pattern
     */
    constructor(noOffsetText, pattern) {
        requireNonNull(noOffsetText, &apos;noOffsetText&apos;);
        requireNonNull(pattern, &apos;pattern&apos;);
        this.noOffsetText = noOffsetText;
        this.type = this._checkPattern(pattern);
    }

    /**
     * @param {String} pattern
     * @return {number}
     */
    _checkPattern(pattern) {
        for (let i = 0; i &lt; PATTERNS.length; i++) {
            if (PATTERNS[i] === pattern) {
                return i;
            }
        }
        throw new IllegalArgumentException(&apos;Invalid zone offset pattern: &apos; + pattern);
    }

    /**
     * @param {DateTimePrintContext} context
     * @param {StringBuilder} buf
     * @return {boolean} 
     */
    print(context, buf) {
        var offsetSecs = context.getValue(ChronoField.OFFSET_SECONDS);
        if (offsetSecs == null) {
            return false;
        }
        var totalSecs = MathUtil.safeToInt(offsetSecs);
        if (totalSecs === 0) {
            buf.append(this.noOffsetText);
        } else {
            var absHours = Math.abs(MathUtil.intMod(MathUtil.intDiv(totalSecs, 3600), 100));  // anything larger than 99 silently dropped
            var absMinutes = Math.abs(MathUtil.intMod(MathUtil.intDiv(totalSecs, 60), 60));
            var absSeconds = Math.abs(MathUtil.intMod(totalSecs, 60));
            var bufPos = buf.length();
            var output = absHours;
            buf.append(totalSecs &lt; 0 ? &apos;-&apos; : &apos;+&apos;)
                .appendChar((MathUtil.intDiv(absHours, 10) + &apos;0&apos;)).appendChar(MathUtil.intMod(absHours, 10) + &apos;0&apos;);
            if (this.type &gt;= 3 || (this.type &gt;= 1 &amp;&amp; absMinutes &gt; 0)) {
                buf.append((this.type % 2) === 0 ? &apos;:&apos; : &apos;&apos;)
                    .appendChar((MathUtil.intDiv(absMinutes, 10) + &apos;0&apos;)).appendChar((absMinutes % 10 + &apos;0&apos;));
                output += absMinutes;
                if (this.type &gt;= 7 || (this.type &gt;= 5 &amp;&amp; absSeconds &gt; 0)) {
                    buf.append((this.type % 2) === 0 ? &apos;:&apos; : &apos;&apos;)
                        .appendChar((MathUtil.intDiv(absSeconds, 10) + &apos;0&apos;)).appendChar((absSeconds % 10 + &apos;0&apos;));
                    output += absSeconds;
                }
            }
            if (output === 0) {
                buf.setLength(bufPos);
                buf.append(this.noOffsetText);
            }
        }
        return true;
    }

    /**
     * @param {DateTimeParseContext} context
     * @param {String} text
     * @param {number} position
     * @return {number}
     */
    parse(context, text, position) {
        var length = text.length;
        var noOffsetLen = this.noOffsetText.length;
        if (noOffsetLen === 0) {
            if (position === length) {
                return context.setParsedField(ChronoField.OFFSET_SECONDS, 0, position, position);
            }
        } else {
            if (position === length) {
                return ~position;
            }
            if (context.subSequenceEquals(text, position, this.noOffsetText, 0, noOffsetLen)) {
                return context.setParsedField(ChronoField.OFFSET_SECONDS, 0, position, position + noOffsetLen);
            }
        }

        // parse normal plus/minus offset
        var sign = text[position];  // IOOBE if invalid position
        if (sign === &apos;+&apos; || sign === &apos;-&apos;) {
            // starts
            var negative = (sign === &apos;-&apos; ? -1 : 1);
            var array = [0,0,0,0];
            array[0] = position + 1;
            if ((this._parseNumber(array, 1, text, true) ||
                    this._parseNumber(array, 2, text, this.type &gt;=3) ||
                    this._parseNumber(array, 3, text, false)) === false) {
                // success
                var offsetSecs = MathUtil.safeZero(negative * (array[1] * 3600 + array[2] * 60 + array[3]));
                return context.setParsedField(ChronoField.OFFSET_SECONDS, offsetSecs, position, array[0]);
            }
        }
        // handle special case of empty no offset text
        if (noOffsetLen === 0) {
            return context.setParsedField(ChronoField.OFFSET_SECONDS, 0, position, position + noOffsetLen);
        }
        return ~position;
    }

    /**
     * Parse a two digit zero-prefixed number.
     *
     * @param {number[]} array  the array of parsed data, 0=pos,1=hours,2=mins,3=secs, not null
     * @param {number} arrayIndex  the index to parse the value into
     * @param {string} parseText  the offset ID, not null
     * @param {boolean} required  whether this number is required
     * @return {boolean} true if an error occurred
     */
    _parseNumber(array, arrayIndex, parseText, required) {
        if ((this.type + 3) / 2 &lt; arrayIndex) {
            return false;  // ignore seconds/minutes
        }
        var pos = array[0];
        if ((this.type % 2) === 0 &amp;&amp; arrayIndex &gt; 1) {
            if (pos + 1 &gt; parseText.length || parseText[pos] !== &apos;:&apos;) {
                return required;
            }
            pos++;
        }
        if (pos + 2 &gt; parseText.length) {
            return required;
        }
        var ch1 = parseText[pos++];
        var ch2 = parseText[pos++];
        if (ch1 &lt; &apos;0&apos; || ch1 &gt; &apos;9&apos; || ch2 &lt; &apos;0&apos; || ch2 &gt; &apos;9&apos;) {
            return required;
        }
        var value = (ch1.charCodeAt(0) - 48) * 10 + (ch2.charCodeAt(0) - 48);
        if (value &lt; 0 || value &gt; 59) {
            return required;
        }
        array[arrayIndex] = value;
        array[0] = pos;
        return false;
    }


    toString() {
        var converted = this.noOffsetText.replace(&apos;\&apos;&apos;, &apos;\&apos;\&apos;&apos;);
        return &apos;Offset(&apos; + PATTERNS[this.type] + &apos;,\&apos;&apos; + converted + &apos;\&apos;)&apos;;
    }
}
OffsetIdPrinterParser.INSTANCE_ID = new OffsetIdPrinterParser(&apos;Z&apos;, &apos;+HH:MM:ss&apos;);
OffsetIdPrinterParser.PATTERNS = PATTERNS;

/**
 * Prints or parses a zone ID.
 */
class ZoneIdPrinterParser {

    /**
     *
     * @param {TemporalQuery} query
     * @param {string} description
     */
    constructor(query, description) {
        this.query = query;
        this.description = description;
    }

    //-----------------------------------------------------------------------
    /**
     *
     * @param {DateTimePrintContext } context
     * @param {StringBuilder} buf
     * @returns {boolean}
     */
    print(context, buf) {
        var zone = context.getValueQuery(this.query);
        if (zone == null) {
            return false;
        }
        buf.append(zone.id());
        return true;
    }

    //-----------------------------------------------------------------------
    /**
     * This implementation looks for the longest matching string.
     * For example, parsing Etc/GMT-2 will return Etc/GMC-2 rather than just
     * Etc/GMC although both are valid.
     * &lt;p&gt;
     * This implementation uses a tree to search for valid time-zone names in
     * the parseText. The top level node of the tree has a length equal to the
     * length of the shortest time-zone as well as the beginning characters of
     * all other time-zones.
     *
     * @param {DateTimeParseContext} context
     * @param {String} text
     * @param {number} position
     * @return {number}
     */
    parse(context, text, position) {
        var length = text.length;
        if (position &gt; length) {
            return ~position;
        }
        if (position === length) {
            return ~position;
        }

        // handle fixed time-zone IDs
        var nextChar = text.charAt(position);
        if (nextChar === &apos;+&apos; || nextChar === &apos;-&apos;) {
            var newContext = context.copy();
            var endPos = OffsetIdPrinterParser.INSTANCE_ID.parse(newContext, text, position);
            if (endPos &lt; 0) {
                return endPos;
            }
            var offset = newContext.getParsed(ChronoField.OFFSET_SECONDS);
            var zone = ZoneOffset.ofTotalSeconds(offset);
            context.setParsedZone(zone);
            return endPos;
        } else if (length &gt;= position + 2) {
            var nextNextChar = text.charAt(position + 1);
            if (context.charEquals(nextChar, &apos;U&apos;) &amp;&amp;
                            context.charEquals(nextNextChar, &apos;T&apos;)) {
                if (length &gt;= position + 3 &amp;&amp;
                                context.charEquals(text.charAt(position + 2), &apos;C&apos;)) {
                    return this._parsePrefixedOffset(context, text, position, position + 3);
                }
                return this._parsePrefixedOffset(context, text, position, position + 2);
            } else if (context.charEquals(nextChar, &apos;G&apos;) &amp;&amp;
                    length &gt;= position + 3 &amp;&amp;
                    context.charEquals(nextNextChar, &apos;M&apos;) &amp;&amp;
                    context.charEquals(text.charAt(position + 2), &apos;T&apos;)) {
                return this._parsePrefixedOffset(context, text, position, position + 3);
            }
        }
        // javascript special case
        if(text.substr(position, 6) === &apos;SYSTEM&apos;){
            context.setParsedZone(ZoneId.systemDefault());
            return position + 6;
        }

        // ...
        if (context.charEquals(nextChar, &apos;Z&apos;)) {
            context.setParsedZone(ZoneOffset.UTC);
            return position + 1;
        }
        // ...
        return ~position;
    }

    /**
     *
     * @param {DateTimeParseContext} context
     * @param {String} text
     * @param {number} prefixPos
     * @param {number} position
     * @return {number}
     */
    _parsePrefixedOffset(context, text, prefixPos, position) {
        var prefix = text.substring(prefixPos, position).toUpperCase();
        var newContext = context.copy();
        if (position &lt; text.length &amp;&amp; context.charEquals(text.charAt(position), &apos;Z&apos;)) {
            context.setParsedZone(ZoneIdFactory.ofOffset(prefix, ZoneOffset.UTC));
            return position;
        }
        var endPos = OffsetIdPrinterParser.INSTANCE_ID.parse(newContext, text, position);
        if (endPos &lt; 0) {
            context.setParsedZone(ZoneIdFactory.ofOffset(prefix, ZoneOffset.UTC));
            return position;
        }
        var offsetSecs = newContext.getParsed(ChronoField.OFFSET_SECONDS);
        var offset = ZoneOffset.ofTotalSeconds(offsetSecs);
        context.setParsedZone(ZoneIdFactory.ofOffset(prefix, offset));
        return endPos;
    }

    /**
     *
     * @returns {string}
     */
    toString() {
        return this.description;
    }
}

export function _init() {
    ReducedPrinterParser.BASE_DATE = LocalDate.of(2000, 1, 1);

    DateTimeFormatterBuilder.CompositePrinterParser = CompositePrinterParser;
    DateTimeFormatterBuilder.PadPrinterParserDecorator = PadPrinterParserDecorator;
    DateTimeFormatterBuilder.SettingsParser = SettingsParser;
    DateTimeFormatterBuilder.CharLiteralPrinterParser = StringLiteralPrinterParser;
    DateTimeFormatterBuilder.StringLiteralPrinterParser = StringLiteralPrinterParser;
    DateTimeFormatterBuilder.CharLiteralPrinterParser = CharLiteralPrinterParser;
    DateTimeFormatterBuilder.NumberPrinterParser = NumberPrinterParser;
    DateTimeFormatterBuilder.ReducedPrinterParser = ReducedPrinterParser;
    DateTimeFormatterBuilder.FractionPrinterParser = FractionPrinterParser;
    DateTimeFormatterBuilder.OffsetIdPrinterParser = OffsetIdPrinterParser;
    DateTimeFormatterBuilder.ZoneIdPrinterParser = ZoneIdPrinterParser;
}</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.4.6)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
